<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here">
<meta property="og:type" content="website">
<meta property="og:title" content="Youngseo&#39;s blog">
<meta property="og:url" content="https://github.com/youngseoim.github.io/index.html">
<meta property="og:site_name" content="Youngseo&#39;s blog">
<meta property="og:description" content="All Dev stories found in here">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="youngseoim">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/youngseoim.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'ko'
  };
</script>

  <title>Youngseo's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Youngseo's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome node.jser..</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>홈</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>아카이브</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/23/Javascript%20TIL%2020200923%20(prototype)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/Javascript%20TIL%2020200923%20(prototype)/" class="post-title-link" itemprop="url">Javascript TIL (Prototype)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-09-23 20:30:59 / Updated at: 20:42:51" itemprop="dateCreated datePublished" datetime="2020-09-23T20:30:59+09:00">2020-09-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="프로토-타입"><a href="#프로토-타입" class="headerlink" title="프로토 타입"></a>프로토 타입</h2><ol>
<li>자바스크립트는 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍(OOP; Object Oriented Programming)을 지원하는 멀티 패러다임 프로그래밍 언어다.</li>
<li>자바스크립트는 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 객체지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 객체 지향 프로그래밍 언어다.</li>
<li><strong>클래스(class)</strong><ol>
<li>ES6에서 클래스가 도입되었다 하지만 ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고 새로운 객체지향 모델을 제공하는 것은 아니다. 사실 클래스도 함수이며, 기존 프로토타입 기반 패턴의 문법적 설탕이라고 볼 수 있다.</li>
<li>클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다. 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다 .</li>
</ol>
</li>
<li><strong>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다.</strong></li>
<li>원시 타입의 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등 )은 모두 객체다.</li>
</ol>
<h3 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h3><ol>
<li>객체지향 프로그래밍(Object Oriented Programming, OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(imperative programming)의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위 즉, 객체(object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.</li>
<li>객체지향 프로그래밍은 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다. 실체는 특징이나 성질을 나타내는 **속성(attribute.property)**을 가지고 있고, 이를 통해 실체를 인식하거나 구별할 수 있다.</li>
<li>다양한 속성 중에서 프로그램에 필요한 속상만 간추려 내어 표현하는 것을 **추상화(abstraction)**이라고 한다.</li>
<li>이 때 “이름”과 “주소”라는 속성을 갖는 person이라는 객체를 자바스크립트로 표현하면 다음과 같다 .</li>
<li><img width="258" alt="스크린샷 2020-09-23 오후 5 44 46" src="https://user-images.githubusercontent.com/68043654/93989478-eb38b180-fdc4-11ea-82d6-b9a0690e5f4c.png"></li>
<li>이때 프로그래머는 이름과 주소 속성으로 표현된 객체인 person을 다른 객체와 구별하여 인식할 수 있다.</li>
<li>이처럼 <strong>속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조</strong>를 객체라고 하며, </li>
<li>객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.</li>
<li>객체지향 프로그래밍은 객체의 **상태(state)**를 나타내는 데이터와 상태 데이터를 조작할 수 있는 **동작(behavior)**을 하나의 논리적인 단위로 묶어 생각한다.</li>
<li>따라서 객체는 <strong>상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조</strong>라고 할 수 있다.</li>
<li>이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라고 부른다.</li>
<li>각 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성(relationship)을 가질 수 있다. 다른 객체와 메세지를 주고 받거나 데이터를 처리할 수도 있다. 또는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다 .</li>
</ol>
<h3 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h3><ol>
<li>상속(inheritance)은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</li>
<li>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용하는 것이다. 코드 재사용은 개발 비용을 현저히 줄일 수 있는 잠재력이 있으므로 매우 중요하다. </li>
<li><img width="537" alt="스크린샷 2020-09-23 오후 5 55 12" src="https://user-images.githubusercontent.com/68043654/93990681-6058b680-fdc6-11ea-96af-95fa1a750a3f.png"></li>
<li>생성자 함수에서 살펴본 바와 같이 생성자 함수는 동일한 프로퍼티 구조를 갖는 객체를 여러 개 생성할 때 유용하다 하지만 위 예제의 생성자 함수는 문제가 있다.</li>
<li>Circle 생성자 함수가 생성하는 모든 객체(인스턴스)는 radius 프로퍼티와 getArea 메서드를 갖는다. radius 프로퍼티 값은 일반적으로 인스턴스마다 다르다(같은 상태를 갖는 여러 개의 인스턴스가 필요하다면 radius 프로퍼티 값이 같을 수도 있다). 하지만 getArea 메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</li>
<li>이는 메모리를 불필요하게 낭비하고 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 준다 .</li>
<li>상속을 통해 불필요한 중복을 제거하면 다음과 같다 ( <strong>자바스크립트는 프로토타입(protype)을 기반으로 상속을 구현한다.</strong>)</li>
<li><img width="555" alt="스크린샷 2020-09-23 오후 6 05 23" src="https://user-images.githubusercontent.com/68043654/93991886-cc87ea00-fdc7-11ea-93ed-3d656e3e0aeb.png"></li>
<li><img width="555" alt="스크린샷 2020-09-23 오후 6 06 16" src="https://user-images.githubusercontent.com/68043654/93991966-eb867c00-fdc7-11ea-854c-152fd3822bba.png"></li>
<li>Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다.</li>
<li>getArea 메서드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메서드로 할당되어 있다. 따라서 Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메서드를 상속받아 사용할 수 있다. 즉, 자신의 상태를 나타내는 radius 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용하는 것이다.</li>
<li>상속은 코드의 재사용이란 관점에서 매우 유용하다. 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해 두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현 없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.</li>
</ol>
<h3 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h3><ol>
<li>프로토타입 객체란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.</li>
<li>모든 객체는[[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조(null인 경우도 있다)다.</li>
<li>이 내부 슬롯에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다. </li>
<li>생성 방식에 따른 프로토타입<ol>
<li>객체 리터럴 = Object.prototype</li>
<li>생성자 함수 = 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체.</li>
</ol>
</li>
<li>모든 객체는 하나의 프로토타입을 갖는다.([[Prototype]] 내부 슬롯의 값이 null인 객체는 프로토타입이 없다.) 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 다음 그림과 같이 서로 연결되어 있다.<ol>
<li><img width="555" alt="스크린샷 2020-09-23 오후 6 20 07" src="https://user-images.githubusercontent.com/68043654/93993557-dad70580-fdc9-11ea-81a5-40a5cd64ab49.png"></li>
</ol>
</li>
<li>[[Prototype]] 내부 슬롯에는 직접 접근할 수 없지만, 위 그림처럼 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있다. 그리고 프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</li>
</ol>
<h3 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__ proto __ 접근자 프로퍼티"></a>__ proto __ 접근자 프로퍼티</h3><ol>
<li><strong>모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉[[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.</strong></li>
<li>내부 슬롯은 프로퍼티가 아니다 따라서 내부 슬롯과 내부 메서드에 직접적인 접근을 하거나 호출할 수 있는 방법을 제공하지 않는다 단, 일부 내부 슬롯과 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하긴한다 </li>
<li>[[prototype]]내부 슬롯에도 직접 접근할 수 없으며 __ proto __ 접근자 프로퍼티를 통해 간접적으로 내부 슬롯값 , 즉 프로토타입에 접근할 수 있다.</li>
<li>Object.prototype의 접근자 프로퍼티인 __ proto __는 getter/setter 함수라고 부르는 접근자 함수 ( [[get]],[[set]] 프로퍼티 어트리뷰트에 할당된 함수 )를 통해 [[ prototype ]] 내부 슬롯의 값, 프로토타입을 취득하거나 할당한다.</li>
<li><strong>__ proto __ 접근자 프로퍼티는 상속을 통해 사용된다.</strong></li>
<li>이 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다.</li>
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/22/Javascript%20TIL%2020200922%20(%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/Javascript%20TIL%2020200922%20(%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6)/" class="post-title-link" itemprop="url">Javascript TIL (Function and first-class object)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-09-22 18:30:59" itemprop="dateCreated datePublished" datetime="2020-09-22T18:30:59+09:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-09-23 20:42:56" itemprop="dateModified" datetime="2020-09-23T20:42:56+09:00">2020-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="일급-객체"><a href="#일급-객체" class="headerlink" title="일급 객체"></a>일급 객체</h2><ol>
<li>무명의 리터럴로 생성할 수 있다 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
<li>위와 같은 조건을 만족하는 객체를 <strong>일급 객체</strong>라고 하고 자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체이다.</li>
<li><img width="478" alt="스크린샷 2020-09-22 오후 4 56 44" src="https://user-images.githubusercontent.com/68043654/93857108-09cf7780-fcf5-11ea-845b-f1bd1ce58f0c.png"></li>
<li>함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티 값, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임(runtime)에 함수 객체로 평가된다.</li>
<li>일급 객체로서 함수가 가지는 가장 큰 특징은 일반 객체와 같이 함수의 매개변수에 전달할 수 있으며, 함수의 반환값으로 사용할 수도 있다는 것이다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중에 하나이다.</li>
<li>함수는 객체이지만 일반 객체와는 차이가 있다 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다 그리고 함수 객체는 일반 객체에는 없는 함수 고유 프로퍼티를 소유한다.</li>
</ol>
<h2 id="함수-객체의-프로퍼티"><a href="#함수-객체의-프로퍼티" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h2><ol>
<li>함수는 객체이다 . 따라서 함수도 프로퍼티를 가질 수 있다. 브라우저 콘솔에서 console.dir 메서드를 사용하여 함수 객체의 내부를 들여다 보자.</li>
<li><img width="237" alt="스크린샷 2020-09-22 오후 5 02 57" src="https://user-images.githubusercontent.com/68043654/93857659-e6f19300-fcf5-11ea-8e8d-25c91cd05819.png"></li>
<li>square 함수의 모든 프로퍼티의 프로퍼티 어트리뷰트를 Object.getOwnPropertyDescriptors 메서드로 확인해보면 다음과 같다 </li>
<li><img width="654" alt="스크린샷 2020-09-22 오후 5 07 43" src="https://user-images.githubusercontent.com/68043654/93858088-92024c80-fcf6-11ea-850b-68826d08cab8.png"></li>
<li>이처럼 arguments, caller, length, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티다</li>
<li>이들 프로퍼티는 일반 객체에는 없는 함수 객체 고유의 프로퍼티다. 하지만 __ proto __ 는 접근자 프로퍼티이며, 함수 객체 고유의 프로퍼티가 아니라 Object.prototype 객체의 프로퍼티를 상속받은 것을 알 수 있다.</li>
<li>Object.prototype 객체의 프로퍼티는 모든 객체가 상속받아 사용할 수 있다. 즉 Object.prototype 객체의 __ proto __ 접근자 프로퍼티는 모든 객체가 사용할 수 있다.</li>
</ol>
<h3 id="함수-객체의-프로퍼티-1"><a href="#함수-객체의-프로퍼티-1" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h3><ol>
<li><h4 id="arguments-프로퍼티"><a href="#arguments-프로퍼티" class="headerlink" title="arguments 프로퍼티"></a>arguments 프로퍼티</h4><ol>
<li><p>함수 객체의 arguments 프로퍼티 값은 arguments 객체다 </p>
</li>
<li><p>Arguments 객체는 함수 호출 시 전달된 인수(arguments)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다. 즉 , 함수 외부에서는 참조할 수 없다 .</p>
</li>
<li><p>함수 객체의 arguments 프로퍼티는 현재 일부 브라우저에서 지원하고 있지만 ES3부터 표준에서 폐지되었다. 따라서 function.arguments와 같은 사용법은 권장되지 않으며 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다 .</p>
</li>
<li><p>자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않는다 따라서 함수 호출 시 매개변수 개수만큼 인수를 전달하지 않아도 에러가 발생하지 않는다 .</p>
</li>
<li><p>함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수 가 할당된다.</p>
</li>
<li><p>선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 인수가 전달되지 않은 매개변수는 undefined로 초기화된 상태를 유지한다. </p>
</li>
<li><p>매개변수의 개수보다 인수를 더 많이 전달한 경우 초과된 인수는 무시된다.</p>
</li>
<li><p>초과된 인수는 그냥 버려지는 것이아니고 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다 .</p>
</li>
<li><img width="404" alt="스크린샷 2020-09-22 오후 5 32 20" src="https://user-images.githubusercontent.com/68043654/93860771-84e75c80-fcfa-11ea-8e1a-ddd8ec81e7f9.png">
</li>
<li><p>arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다 arguments 객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수 즉, 함수 자신을 가리키고 argumetns 객체의 length 프로퍼티는 인수의 개수를 가리킨다.</p>
</li>
<li><p>arguments 객체의 Symbol(Symbol.iterator) 프로퍼티</p>
<p>arguments 객체의 Symbol(Symbol.iterator) 프로퍼티는 arguments 객체를 순회 가능한 자료구조인 이터러블(iterable)로 만들기 위한 프로퍼티다. Symbol.iterator를 프로퍼티 키로 사용한 메서드를 구현하는 것에 의해 이터러블이 된다</p>
</li>
<li><p>선언된 매개 변수의 개수와 함수를 호출할 때 전달하는 인수의 개수를 확인하지 않는 자바스크립트의 특성 때문에 함수가 호출되면 인수 개수를 확인하고 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다 이때 유용하게 사용되는 것이 arguments 객체다.</p>
</li>
<li><p>argumetns 객체는 매개변수 개수를 확정할 수 없는 <strong>가변 인자 함수</strong>를 구현할 때 유용하다.</p>
</li>
<li><img width="616" alt="스크린샷 2020-09-22 오후 6 04 38" src="https://user-images.githubusercontent.com/68043654/93863498-8581f200-fcfe-11ea-9cad-981670fc35d9.png">
</li>
<li><p>Arguments 객체는 배열 형태로 인자 정보를 담고 있지만 실제 배열이 아닌 유사 배열 객체(array-like object)다.</p>
</li>
<li><p>유사 배열 객체란 length 프로퍼티를 가진 객체로 for 문으로 순회할 수 있는 객체를 말한다.</p>
</li>
<li><p>유사배열 객체와 이터러블</p>
<ol>
<li>ES6에서 도입된 [이터레이션 프로토콜]을 준수하면 순회 가능한 자료구조인 이터러블이 된다. 이터러블의 개념이 없었던 ES5에서 arguments 객체는 유사 배열 객체로 구분되었다. 하지만 이터러블이 도입된 ES6부터 arguments 객체는 유사 배열 객체이면서 동시에 이터러블이다.</li>
</ol>
</li>
<li><p>유사 배열 객체는 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다 따라서 배열 메서드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해 간접 호출해야 하는 번거로움이 있다.</p>
</li>
<li><img width="500" alt="스크린샷 2020-09-22 오후 6 11 38" src="https://user-images.githubusercontent.com/68043654/93864210-7fd8dc00-fcff-11ea-9ddc-29480560f3c0.png">
</li>
<li><p>이러한 번거로움을 해결하기 위해 ES6에서는 Rest 파라미터를 도입했다</p>
</li>
<li><img width="500" alt="스크린샷 2020-09-22 오후 6 13 55" src="https://user-images.githubusercontent.com/68043654/93864408-d1816680-fcff-11ea-8cef-ee9a79db560f.png">
</li>
<li><p>ES6 Rest 파라미터의 도입으로 모던 자바스크립트에서는 arguments 객체의 중요성이 이전 같지는 않지만 언제나 ES6만 사용하지는 않을 수 있기 때문에 알아둘 필요가 있다.</p>
</li>
</ol>
</li>
<li><h3 id="Length-프로퍼티"><a href="#Length-프로퍼티" class="headerlink" title="Length 프로퍼티"></a>Length 프로퍼티</h3><ol>
<li>함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.</li>
<li><img width="253" alt="스크린샷 2020-09-22 오후 6 18 29" src="https://user-images.githubusercontent.com/68043654/93864858-74d27b80-fd00-11ea-8ec0-4c3d59566dc4.png"></li>
<li>arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의해야 한다. arguments 객체의 length 프로퍼티는 인자 (arguments)의 개수를 가리키고 함수 객체의 length 프로퍼티는 매개변수(parameter)의 개수를 가리킨다.</li>
</ol>
</li>
<li><h3 id="name-프로퍼티"><a href="#name-프로퍼티" class="headerlink" title="name 프로퍼티"></a>name 프로퍼티</h3><ol>
<li>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다 . name 프로퍼티는 ES6 이전까지는 비표준이었다가 ES6에서 정식 표준이 되었다</li>
<li>name 프로퍼티는 ES5 와 ES6에서 동작을 달리하므로 주의해야한다 <ol>
<li>익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다 하지만 ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다 .</li>
<li><img width="415" alt="스크린샷 2020-09-22 오후 6 23 07" src="https://user-images.githubusercontent.com/68043654/93865320-1a85ea80-fd01-11ea-85b9-c6d5a520e5ec.png"></li>
<li>함수 이름과 함수 객체를 가리키는 식별자는 의미가 다르다는 것을 잊지 말아야 한다 함수를 호출할 때는 함수 이름이 아닌 함수 객체를 가리키는 식별자로 호출한다 .</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__ proto __ 접근자 프로퍼티"></a>__ proto __ 접근자 프로퍼티</h3><ol>
<li>모든 객체는 [[prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</li>
<li>__ proto __ 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다 내부 슬롯에는 직접 접근할 수 없고 간접적인 방법을 제공하는 경우에 한하여 접근할 수 있다. [[prototype]] 내부 슬롯에도 직접 접근할 수 없으며 __ proto __ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다.</li>
<li><img width="565" alt="스크린샷 2020-09-22 오후 6 26 25" src="https://user-images.githubusercontent.com/68043654/93865650-9122e800-fd01-11ea-8539-a909009b5c94.png"></li>
<li>hasOwnProperty 메서드는 이름에서 알 수 있듯이 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고 상속받은 프로토타입의 프로퍼티 키인 경우 false를 반환한다.</li>
</ol>
</li>
<li><h3 id="prototype-프로퍼티"><a href="#prototype-프로퍼티" class="headerlink" title="prototype 프로퍼티"></a>prototype 프로퍼티</h3><ol>
<li>Prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티다 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없다.</li>
<li><img width="420" alt="스크린샷 2020-09-22 오후 6 28 40" src="https://user-images.githubusercontent.com/68043654/93865873-e19a4580-fd01-11ea-8523-f177e5094f57.png"></li>
<li>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/21/Javascript%20TIL%2020200921%2017%E1%84%80%E1%85%A1%E1%86%BC(%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A6%20%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/21/Javascript%20TIL%2020200921%2017%E1%84%80%E1%85%A1%E1%86%BC(%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A6%20%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20)/" class="post-title-link" itemprop="url">Javascript TIL (Object creation by constructor function)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-09-21 22:25:59 / Updated at: 22:27:58" itemprop="dateCreated datePublished" datetime="2020-09-21T22:25:59+09:00">2020-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h2><ol>
<li>다양한 객체 생성 방식 중 생성자 함수를 사용하여 객체를 생성하는 방식을 살펴보자.</li>
<li>객체 리터럴을 사용하여 객체를 생성하는 방식과의 장단점을 살펴보자.</li>
</ol>
<h3 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object 생성자 함수"></a>Object 생성자 함수</h3><ol>
<li>New 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있다.</li>
<li><img width="437" alt="스크린샷 2020-09-21 오후 7 49 19" src="https://user-images.githubusercontent.com/68043654/93758764-f912f900-fc43-11ea-9c6c-47440a333983.png"></li>
<li>생성자 함수 (constructor)란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라고 한다 .</li>
<li>자바스크립트는 Object 생성자 함수 이외에도 String,Number,Boolean,Function, Array, Date, RegExp,Promise 등의 빌트인 생성자 함수를 제공한다.</li>
<li><img width="546" alt="스크린샷 2020-09-21 오후 7 54 29" src="https://user-images.githubusercontent.com/68043654/93759187-b1d93800-fc44-11ea-850d-8c2a9bf66154.png">
<img width="546" alt="스크린샷 2020-09-21 오후 7 54 51" src="https://user-images.githubusercontent.com/68043654/93759207-bdc4fa00-fc44-11ea-81f3-76110ec74d39.png"></li>
<li>반드시 Object 생성자 함수를 사용해 빈 객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을  사용하는 것이 더 간편하다. Object 생성자 함수를 사용해 객체를 생성하는 방식은 특별한 이유가 없다면 그다지 유용해 보이지 않는다,</li>
</ol>
<h3 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h3><h4 id="객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="객체 리터럴에 의한 객체 생성 방식의 문제점"></a>객체 리터럴에 의한 객체 생성 방식의 문제점</h4><ol>
<li>객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.</li>
<li><img width="458" alt="스크린샷 2020-09-21 오후 8 07 54" src="https://user-images.githubusercontent.com/68043654/93760228-91aa7880-fc46-11ea-9abb-29a85951d078.png"></li>
<li>객체는 프로퍼티를 통해 객체 고유의 상태(state)를 표현한다. 그리고 메서드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작(behavior)을 표현한다. 따라서 프로퍼티는 객체마다 프로퍼티 값이 다를 수 있지만 메서드는 내용이 동일한 경우가 일반적이다.</li>
<li>원을 표현한 객체인 circle1 객체와 circle2 객체는 프로퍼티 구조가 동일하다, 객체 고유의 상태 데이터인 radius 프로퍼티의 값은 객체마다 다를 수 있지만 getDiameter 메서드는 완전히 동일하다.</li>
<li>하지만 객체 리터럴에 의해 객체를 생성하는 경우 프로퍼티 구조가 동일함에도 불구하고 매번 같은 프로퍼티와 메서드를 기술해야 한다. 앞의 예제처럼 객체가 한두개라면 넘어갈 수도 있겠지만 만약 수십 개의 객체를 생성해야 한다면 문제가 크다.</li>
</ol>
<h4 id="생성자-함수에-의한-객체-생성-방식의-장점"><a href="#생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="생성자 함수에 의한 객체 생성 방식의 장점"></a>생성자 함수에 의한 객체 생성 방식의 장점</h4><ol>
<li><p>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p>
</li>
<li><img width="520" alt="스크린샷 2020-09-21 오후 8 21 52" src="https://user-images.githubusercontent.com/68043654/93761290-85271f80-fc48-11ea-8805-5ded4a9fc2dc.png">
</li>
<li><p>this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수(self-referencing variable)다. <strong>this가 가리키는 값, 즉 this  바인딩은 함수 호출 방식에 따라 동적으로 결정된다.</strong></p>
</li>
<li><table>
<thead>
<tr>
<th align="left">함수 호출 방식</th>
<th align="left">this가 가리키는 값(this 바인딩)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">일반 함수로서 호출</td>
<td align="left">전역 객체</td>
</tr>
<tr>
<td align="left">메서드로서 호출</td>
<td align="left">메서드를 호출한 객체(마침표 앞의 객체)</td>
</tr>
<tr>
<td align="left">생성자 함수로서 호출</td>
<td align="left">생성자 함수가 (미래에) 생성할 인스턴스</td>
</tr>
</tbody></table>
</li>
<li><img width="487" alt="스크린샷 2020-09-21 오후 8 31 01" src="https://user-images.githubusercontent.com/68043654/93762028-cc61e000-fc49-11ea-9011-4aeb9da6b873.png">
</li>
<li><p>생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 <strong>new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</strong> 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다 .</p>
</li>
<li><img width="501" alt="스크린샷 2020-09-21 오후 8 47 31" src="https://user-images.githubusercontent.com/68043654/93763275-1a77e300-fc4c-11ea-9049-d759ca867326.png">

</li>
</ol>
<h4 id="생성자-함수의-인스턴스-생성-과정"><a href="#생성자-함수의-인스턴스-생성-과정" class="headerlink" title="생성자 함수의 인스턴스 생성 과정"></a>생성자 함수의 인스턴스 생성 과정</h4><ol>
<li>먼저 생성자 함수의 함수 몸체에서 수행해야 하는 것이 무엇인지 생각해보자. 생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 <strong>인스턴스를 생성</strong>하는 것과 **생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)**하는 것이다 </li>
<li>생성자 함수가 인스턴스를 생성하는 것은 필수이고 생성된 인스턴스를 초기화하는 것은 옵션이다.</li>
<li><img width="444" alt="스크린샷 2020-09-21 오후 8 53 45" src="https://user-images.githubusercontent.com/68043654/93763770-f8cb2b80-fc4c-11ea-9ff8-7c6dfd323ade.png"></li>
<li>생성자 함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 전달된 인수를 프로퍼티의 초기값으로서 할당하여 인스턴스를 초기화한다 하지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다</li>
<li>자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 다음과 같은 과정을 거쳐 암묵적으로 인스턴스를 생성하고 인스턴스를 초기화한 후 암묵적으로 인스턴스를 반환한다.</li>
<li><strong>인스턴스 생성과 this 바인딩</strong><ol>
<li>암묵적으로 빈 객체가 생성된다 . 이 빈 객체가 바로(아직 완성되지는 않았지만) 생성자 함수가 생성한 인스턴스다 그리고 암묵적으로 생성된 빈 객체 즉 인스턴스는 this에 바인딩된다.</li>
<li>생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다 이 처리는 함수 몸체의 코드가 한 줄씩 실행되는 런타임 이전에 실행된다.</li>
<li><strong>바인딩(binding)이란</strong><ol>
<li>식별자와 값을 연결하는 과정을 의미한다 예를 들어 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다)와 가리킬 객체를 바인딩하는 것이다.</li>
<li><img width="458" alt="스크린샷 2020-09-21 오후 9 19 46" src="https://user-images.githubusercontent.com/68043654/93765911-9bd17480-fc50-11ea-84d7-420a6ac6df8c.png"></li>
</ol>
</li>
</ol>
</li>
<li><strong>인스턴스 초기화</strong><ol>
<li>생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다 즉 ,this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다. 이 처리는 개발자가 기술한다.</li>
<li><img width="458" alt="스크린샷 2020-09-21 오후 9 29 05" src="https://user-images.githubusercontent.com/68043654/93766781-e99aac80-fc51-11ea-969c-6b0138b2f7d7.png"></li>
</ol>
</li>
<li><strong>인스턴스 반환</strong><ol>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스의 바인딩된 this가 암묵적으로 반환된다.</li>
<li><img width="420" alt="스크린샷 2020-09-21 오후 9 30 55" src="https://user-images.githubusercontent.com/68043654/93766912-29fa2a80-fc52-11ea-8b4d-6c044b07e659.png"></li>
<li>만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환된다.</li>
<li><img width="425" alt="스크린샷 2020-09-21 오후 9 34 40" src="https://user-images.githubusercontent.com/68043654/93767247-af7dda80-fc52-11ea-8cd2-a77049d1a041.png"></li>
<li>하지만 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.</li>
<li><img width="475" alt="스크린샷 2020-09-21 오후 9 39 08" src="https://user-images.githubusercontent.com/68043654/93767700-51052c00-fc53-11ea-915e-159a6b3729cb.png"></li>
<li>이처럼 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 생성자 함수 내부에서 return 문을 반드시 생략해야 한다 .</li>
</ol>
</li>
</ol>
<h4 id="내부-메서드-call-과-construct"><a href="#내부-메서드-call-과-construct" class="headerlink" title="내부 메서드 [[call]]과 [[construct]]"></a>내부 메서드 [[call]]과 [[construct]]</h4><ol>
<li>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.</li>
<li>생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다.</li>
<li>함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기 때문이다 .</li>
<li><img width="276" alt="스크린샷 2020-09-21 오후 9 48 31" src="https://user-images.githubusercontent.com/68043654/93768617-9f66fa80-fc54-11ea-8af6-b98d7eb5d960.png"></li>
<li>함수는 객체이지만 일반 객체와는 다르다. <strong>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.</strong> 따라서 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론, 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]]등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가지고 있다.</li>
<li>함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드[[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.</li>
<li><img width="322" alt="스크린샷 2020-09-21 오후 9 52 19" src="https://user-images.githubusercontent.com/68043654/93768965-287e3180-fc55-11ea-9414-c6e0fe2fb54f.png"></li>
<li>내부 메서드 [[Call]]을 갖는 함수 객체를 callable이라 하며,<ol>
<li>callable은 호출할 수 있는 객체, 즉 함수를 말한다</li>
</ol>
</li>
<li>내부 메서드 [[Construct]]를 갖는 함수 객체를 constructor,<ol>
<li>constrictor는 생성자 함수로서 호출할 수 있는 함수</li>
</ol>
</li>
<li>[[Constructor]]를 갖지 않는 함수 객체를 non-constructor라고 부른다.<ol>
<li>non-constructor는 객체를 생성자 함수로서 호출할 수 없는 함수</li>
</ol>
</li>
<li>결론적으로 함수 객체는 constructor이거나 callable이면서 non-constructor다  즉, 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있늨 것은 아니다.</li>
</ol>
<h4 id="constructor-와-non-contructor의-구분"><a href="#constructor-와-non-contructor의-구분" class="headerlink" title="constructor 와 non-contructor의 구분"></a>constructor 와 non-contructor의 구분</h4><ol>
<li>자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 contructor와 non-constructor로 구분한다.<ol>
<li>Constructor = 함수 선언문, 함수 표현식, 클래스(클래스도 함수)</li>
<li>non-constructor = 메서드(ES6 메서드 축약 표현), 화살표 함수</li>
</ol>
</li>
<li>이때 주의할 것은 ECMAScript 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드 보다 좁다는 것이다. 다음 예제를 살펴보자.</li>
<li><img width="507" alt="스크린샷 2020-09-21 오후 10 03 13" src="https://user-images.githubusercontent.com/68043654/93770075-ad1d7f80-fc56-11ea-9ea3-486f52f992eb.png"></li>
<li>함수를 프로퍼티 값으로 사용하면 일반적으로 메서드로 통칭한다. 하지만 ECMAScript 사양에서 메서드랑 ES6의 메서드 축약표현 만을 의미한다. 다시 말해 함수가 어디에 할당되어 있는지에 따라 메서드인지를 판단하는 것이 아니라</li>
<li>함수 정의 방식에 따라 constructor와 non-contructor를 구분한다.</li>
<li>따라서 위 예제와 같이 일반 함수 , 즉 함수 선언문과 함수 표현식으로 정의된 함수만이 constructor이고 ES6의 화살표 함수와 메서드 축약 표현으로 정의된 함수는 non-constructor다</li>
<li>함수를 일반 함수로서 호출하면 함수 객체의 내부 메서드[[call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출하면 내부 메서드 [[Construct]]가 호출된다 non-constructor인 함수 객체는 내부 메서드[[Constructor]]를 갖지 않는다 따라서 non-constructor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생한다.</li>
<li><img width="507" alt="스크린샷 2020-09-21 오후 10 07 51" src="https://user-images.githubusercontent.com/68043654/93770574-53698500-fc57-11ea-861d-abbe400ccc4e.png"></li>
<li>주의할 것은 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(callable이면서 construcotr)에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것이다 .</li>
</ol>
<h4 id="new-연산자"><a href="#new-연산자" class="headerlink" title="new 연산자"></a>new 연산자</h4><ol>
<li>일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다 </li>
<li>다시 말해, 함수 객체의 내부 메서드 [[Call]]이 호출되는 것이 아니라 [[Constructor]]가 호출된다 단 new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor여야 한다.</li>
<li><img width="507" alt="스크린샷 2020-09-21 오후 10 16 00" src="https://user-images.githubusercontent.com/68043654/93771441-76486900-fc58-11ea-9fe8-35aac45bf33b.png"></li>
<li>반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다. 다시 말해, 함수 객체의 내부 메서드[[Constructor]]가 호출되는 것이 아니라 [[Call]]이 호출된다.</li>
<li><img width="507" alt="스크린샷 2020-09-21 오후 10 17 18" src="https://user-images.githubusercontent.com/68043654/93771562-a55eda80-fc58-11ea-9191-0725c0a4963e.png"></li>
<li>Circle 함수를 new 연산자와 함께 생성자 함수로서 호출하면 함수 내부의 this 는 Circle 생성자 함수가 생성할 인스턴스를 가리킨다 하지만 Circle 함수를 일반적인 함수로서 호출하면 함수 내부의 this는 전역 객체 window를 가리킨다.</li>
<li>위 예제의 Circle 함수는 일반 함수로서 호출되었기 때문에 Circle 함수 내부의 this는 전역 객체 window를 가리킨다 따라서 radius 프로퍼티와 getDiameter메서드는 전역 객체의 프로퍼티와 메서드가 된다.</li>
<li>일반 함수와 생성자 함수에 특별한 형식적 차이는 없다 따라서 생성자 함수는 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다.</li>
</ol>
<h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><ol>
<li>생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다. 이러한 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다.</li>
<li>new.target은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다. 참고로 IE는 new.target을 지원하지 않으므로 주의하기 바란다.</li>
<li>함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있다. <strong>new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.</strong></li>
<li>따라서 함수 내부에서 new.target을 사용하여 new 연산자와 생성자 함수로서 호출했는지 확인하여 그렇지 않은 경우 new 연산자와 함께 재귀 호출을 통해 생성자 함수로서 호출할 수 있다.</li>
<li><img width="514" alt="스크린샷 2020-09-21 오후 10 23 06" src="https://user-images.githubusercontent.com/68043654/93772155-7432da00-fc59-11ea-9151-2ace04a4077a.png"></li>
<li>스코프 세이프 생성자 패턴(scope-safe constructor)<ol>
<li>new.target은 ES6에서 도입된 최신 문법으로 IE에서는 지원하지 않는다. new.target을 사용할 수 없는 상황이라면 스코프 세이프 생성자 패턴을 사용할 수 있다.</li>
</ol>
</li>
<li><img width="514" alt="스크린샷 2020-09-21 오후 10 23 57" src="https://user-images.githubusercontent.com/68043654/93772247-93316c00-fc59-11ea-8ee5-672115aa23d1.png"></li>
<li>new 연산자와 함께 생성자 함수에 의해 생성된 객체(인스턴스)는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용해 new 연산자와 함께 호출되었는지 확인할 수 있다.</li>
<li>참고로 대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다.</li>
<li>예를 들어, Object와 Function 생성자 함수는 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다.</li>
<li><img width="381" alt="스크린샷 2020-09-21 오후 10 24 55" src="https://user-images.githubusercontent.com/68043654/93772338-b52aee80-fc59-11ea-9f6e-0b073ee7ea13.png"></li>
<li>하지만 String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출했을 때 String, Number, Boolean 객체를 생성하여 반환하지만 new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. 이를 통해 데이터 타입을 변환하기도 한다.</li>
<li><img width="375" alt="스크린샷 2020-09-21 오후 10 25 51" src="https://user-images.githubusercontent.com/68043654/93772489-d68bda80-fc59-11ea-9cb2-00eac7a19e20.png">

</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/21/Javascript%20TIL%20Algorithm%2020200921/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/21/Javascript%20TIL%20Algorithm%2020200921/" class="post-title-link" itemprop="url">Algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-09-21 12:00:59 / Updated at: 13:15:53" itemprop="dateCreated datePublished" datetime="2020-09-21T12:00:59+09:00">2020-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1번-과제"><a href="#1번-과제" class="headerlink" title="1번 과제"></a>1번 과제</h2><ol>
<li><p>1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)<br>1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.<br>단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.<br>(hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n]</p>
</li>
<li><pre><code class="javascript">function getCount8 () &#123;
&#125;
console.log(getCount8()); // 4000
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. &amp;lt;img width&amp;#x3D;&amp;quot;404&amp;quot; alt&amp;#x3D;&amp;quot;스크린샷 2020-09-20 오후 8 27 35&amp;quot; src&amp;#x3D;&amp;quot;https:&amp;#x2F;&amp;#x2F;user-images.githubusercontent.com&amp;#x2F;68043654&amp;#x2F;93710253-24ccab00-fb80-11ea-992f-d05ced40d124.png&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 2번 과제&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 이상한 문자 만들기&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   toWeirdCase함수는 문자열을 인수로 전달받는다. 문자열 s에 각 단어의 짝수번째 인덱스 문자는 대문자로, 홀수번째 인덱스 문자는 소문자로 바꾼 문자열을 리턴하도록 함수를 완성하라.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   예를 들어 s가 ‘hello world’라면 첫 번째 단어는 ‘HeLlO’, 두 번째 단어는 ‘WoRlD’로 바꿔 ‘HeLlO WoRlD’를 리턴한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   주의) 문자열 전체의 짝&amp;#x2F;홀수 인덱스가 아니라 단어(공백을 기준)별로 짝&amp;#x2F;홀수 인덱스를 판단한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. &amp;#96;&amp;#96;&amp;#96;javascript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   function toWeirdCase(s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(toWeirdCase(&amp;#39;hello world&amp;#39;));    &amp;#x2F;&amp;#x2F; &amp;#39;HeLlO WoRlD&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(toWeirdCase(&amp;#39;my name is lee&amp;#39;)); &amp;#x2F;&amp;#x2F; &amp;#39;My NaMe Is LeE&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
</li>
<li><pre><code class="javascript">
function toWeirdCase(s) &#123;  
  var str = &#39;&#39;;
  var space = s.split(&#39; &#39;);
    for(var i = 0; i &lt; s.length; i++)&#123;
      if(i === &#39; &#39;) &#123;

      &#125;
      var j = x % 2 === 0 ? str += s[i].toUpperCase() : s[i].toLowerCase();
  &#125;
  return str;
&#125;
console.log(toWeirdCase(&#39;hello world&#39;));    // &#39;HeLlO WoRlD&#39;
console.log(toWeirdCase(&#39;my name is lee&#39;)); // &#39;My NaMe Is LeE&#39;</code></pre>
</li>
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/17/Date%20Structure%20and%20Algorithm%20(linear%20search%20:%20binary%20search)%2020200917%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Date%20Structure%20and%20Algorithm%20(linear%20search%20:%20binary%20search)%2020200917%20/" class="post-title-link" itemprop="url">Date Structure and Algorithm (linear search / binary search)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-09-17 23:30:59 / Updated at: 23:51:14" itemprop="dateCreated datePublished" datetime="2020-09-17T23:30:59+09:00">2020-09-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1번-과제-선형-검색"><a href="#1번-과제-선형-검색" class="headerlink" title="1번 과제 (선형 검색)"></a>1번 과제 (선형 검색)</h2><ol>
<li><img width="1056" alt="스크린샷 2020-09-17 오후 8 35 07" src="https://user-images.githubusercontent.com/68043654/93465398-b096cb00-f925-11ea-86fa-672411d78f88.png"></li>
<li><img width="492" alt="스크린샷 2020-09-17 오후 8 36 05" src="https://user-images.githubusercontent.com/68043654/93465486-d45a1100-f925-11ea-90a5-2d738c636eb7.png">

</li>
</ol>
<h2 id="2번-과제-이진-검색"><a href="#2번-과제-이진-검색" class="headerlink" title="2번 과제 (이진 검색)"></a>2번 과제 (이진 검색)</h2><ol>
<li><img width="1082" alt="스크린샷 2020-09-17 오후 8 37 08" src="https://user-images.githubusercontent.com/68043654/93465580-f81d5700-f925-11ea-9b00-e8ea521b8263.png"></li>
<li><img width="497" alt="스크린샷 2020-09-17 오후 11 39 04" src="https://user-images.githubusercontent.com/68043654/93486630-63275780-f93f-11ea-962c-e8949ad9d69d.png"></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/17/Javascript%20TIL%2020200917%2016%E1%84%80%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%E1%85%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Javascript%20TIL%2020200917%2016%E1%84%80%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%E1%85%B5/" class="post-title-link" itemprop="url">Javascript TIL (Property Attribute)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-09-17 19:10:59" itemprop="dateCreated datePublished" datetime="2020-09-17T19:10:59+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-09-21 18:12:37" itemprop="dateModified" datetime="2020-09-21T18:12:37+09:00">2020-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Property-Attribute"><a href="#Property-Attribute" class="headerlink" title="Property Attribute"></a>Property Attribute</h2><h3 id="내부-슬롯과-내부-메서드"><a href="#내부-슬롯과-내부-메서드" class="headerlink" title="내부 슬롯과 내부 메서드"></a>내부 슬롯과 내부 메서드</h3><ol>
<li>내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 프로퍼티(pseudo proery)와 의사 메서드(pseudo method)이다. ECMAScript에 등장하는 이중 대괄호( [[…]] )로 감싼 이름들이 내부 슬롯과 내부 메서드이다.</li>
<li>내부 슬롯과 내부 메서드는 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.<ol>
<li>예를 들어, 모든 객체는 [[Property]] 라는 내부 슬롯을 갖는데 이는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 직접 접근할 수 없지만 (__ proto __)를 통해 간접적으로 접근할 수 있다.</li>
</ol>
</li>
</ol>
<h2 id="프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><ol>
<li><strong>자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</strong></li>
<li>프로퍼티의 상태란<ol>
<li>프로퍼티의 값(value)</li>
<li>값의 갱신 가능 여부(writable)</li>
<li>열거 가능 여부(enumerable)</li>
<li>재정의 가능 여부(configurable)을 말한다.</li>
</ol>
</li>
<li>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부 슬롯 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]이다. 따라서 프로퍼티 어트리뷰트에 직접 접근할 수 없지만 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.</li>
<li>Object.getOwnPropertyDescriptor 호출 할 때<ol>
<li>첫번째 매개변수에는 객체의 참조(식별자)를 전달하고</li>
<li>두번째 매개변수에는 프로퍼팅 키를 문자열로 전달한다.</li>
<li>이때 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 <strong>프로퍼티 디스크립터(PropertyDescriptor)객체</strong>를 반환한다.</li>
<li>Object.getOwnPropertyDescriptor 메서드는 하나의 프로퍼티에 대해 디스크립터 객체를 반환하고</li>
<li>Object.getOwnPropertyDescriptors(ES8에 도입)메서드는 모든 프로퍼티에 대해 디스크립터 객체를 반환한다.</li>
</ol>
</li>
</ol>
<h3 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h3><ol>
<li>데이터 프로퍼티(data property)<ol>
<li>키와 값으로 구성된 일반적인 프로퍼티다 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다.</li>
</ol>
</li>
<li>접근자 프로퍼티(accessor property)<ol>
<li>자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수(accessor function)로 구성된 프로퍼티다.</li>
</ol>
</li>
</ol>
<h4 id="데이터-프로퍼티"><a href="#데이터-프로퍼티" class="headerlink" title="데이터 프로퍼티"></a>데이터 프로퍼티</h4><table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>Value</td>
<td>-프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다.<br>-프로퍼티 키를 통해 프로퍼티 값을 변경하면[[value]]에 값을 재할당 한다. 이때 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[value]]에 저장.</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>Writable</td>
<td>- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.<br/>- [[Writable]]의 값이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>Enumerable</td>
<td>- 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. - [[Enumerable]]의 값이 false인 경우 해당 프로퍼티는 for…in 문이나 Object.keys 메서드 등으로 <a target="_blank" rel="noopener" href="https://poiemaweb.com/fastcampus/prototype#14-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%97%B4%EA%B1%B0">열거</a>할 수 없다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>Configurable</td>
<td>- 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.<br/>- [[Configurable]]의 값이 false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.(<a target="_blank" rel="noopener" href="https://poiemaweb.com/fastcampus/property-definition#52-%EA%B0%9D%EC%B2%B4-%EB%B0%80%EB%B4%89">“16.5.2. 객체 밀봉”</a>과 <a target="_blank" rel="noopener" href="https://poiemaweb.com/fastcampus/property-definition#53-%EA%B0%9D%EC%B2%B4-%EB%8F%99%EA%B2%B0">“16.5.3. 객체 동결”</a> 참고)</td>
</tr>
</tbody></table>
<h4 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h4><ol>
<li><p>접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다.</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">프로퍼티 어트리뷰트</th>
<th align="left">프로퍼티 디스크립터 객체의 프로퍼티</th>
<th align="left">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[[Get]]</td>
<td align="left">get</td>
<td align="left">접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수다. 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</td>
</tr>
<tr>
<td align="left">[[Set]]</td>
<td align="left">set</td>
<td align="left">접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td align="left">[[Enumerable]]</td>
<td align="left">enumerable</td>
<td align="left">데이터 프로퍼티의 [[Enumerable]]과 같다.</td>
</tr>
<tr>
<td align="left">[[Configurable]]</td>
<td align="left">configurable</td>
<td align="left">데이터 프로퍼티의 [[Configurable]]과 같다.</td>
</tr>
</tbody></table>
<p>접근자 함수는 getter / setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.</p>
<ol>
<li><img width="711" alt="스크린샷 2020-09-17 오후 6 42 06" src="https://user-images.githubusercontent.com/68043654/93454388-e764e500-f915-11ea-8444-be209dbe31ff.png"></li>
<li><img width="505" alt="스크린샷 2020-09-17 오후 6 41 08" src="https://user-images.githubusercontent.com/68043654/93454305-c43a3580-f915-11ea-8e1f-9bda5bada2a0.png"></li>
<li>Person 객체의 firstName과 lastName 프로퍼티는 일반적인 데이터 프로퍼티다. 메서드 앞에 get,set이 붙은 메서드가 있는데 이것들이 바로 getter와 setter함수이고, getter/setter 함수의 이름 fullName이 접근자 프로퍼티다</li>
<li>접근자 프로퍼티는 자체적으로 값(프로퍼티 어트리뷰트[[value]])를 가지지 않으며 다만 데이터 프로퍼티의 값을 읽거나 저장할 때 관여할 뿐이다.</li>
<li>이를 내부 슬롯/메서드 관점에서 설명하면 다음과 같다. 접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메서드가 호출되어 다음과 같이 동작한다.<ol>
<li>ECMAScript 스펙에서 정의한 [[Get]] 내부 메서드의 사양을 만족시키는 구현체가 자바스크립트 엔진에 존재한다는 것이 중요하지 [[Get]]이란 이름으로 실제 자바스크립트 엔진이 구현되었는지는 중요하지 않다. 어차피 [[Get]] 내부 메서드에 직접 접근할 수도 없다 . </li>
<li>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심벌이어야 한다. 프로퍼티 키 “fullName”은 문자열이므로 유효한 프로퍼티 키이다.</li>
<li>프로토타입 체인에서 프로퍼티를 검색한다. person 객체에 fullName 프로퍼티가 존재한다.</li>
<li>검색된 fullName 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName은 접근자 프로퍼티이다.</li>
<li>접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트[[Get]]의 값은 Object.getOwnPropertyDescriptor 메서드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다.</li>
</ol>
</li>
<li><strong>프로토타입(prototype)</strong><ol>
<li>프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체다.</li>
<li>프로토타입은 하위 객체에게 자신의 프로퍼티와 메서드를 상속한다.</li>
<li>프로토타입 객체의 프로퍼티나 메서드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메서드인 것처럼 자유롭게 사용할 수 있다.</li>
<li>프로토타입 체인은 프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 말한다 객체의 프로퍼티나 메서드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면 프로토타입 체인을 따라 프로토타입의 프로퍼티나 메서드를 차례대로 검색한다.</li>
</ol>
</li>
<li><img width="523" alt="스크린샷 2020-09-17 오후 7 10 39" src="https://user-images.githubusercontent.com/68043654/93457398-e3d35d00-f919-11ea-8eb6-2e98ca12b3e7.png">
1. Object.getOwnPropertyDescriptor 메서드가 반환한 프로퍼티 어트리뷰트를 객체로 표현한 프로퍼티 디스크립터 객체를 유심히 살펴보자. 접근자 프로퍼티와 데이터 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티가 다른 것을 알 수 있다.

</li>
</ol>
</li>
</ol>
<h2 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h2><ol>
<li><p>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다 .</p>
</li>
<li><p>예를 들어, 프로퍼티 값을 갱신 가능하도록 할 것인지</p>
</li>
<li><p>프로퍼티를 열거 가능하도록 할 것인지, </p>
</li>
<li><p>프로퍼티를 재정의 가능하도록 할 것인지 정의할 수 있다. 이를통해 객체의 프로퍼티가 어떻게 동작해야 하는지를 명확히 정의할 수 있다.</p>
</li>
<li><p>Object.defineProperty method를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수로는 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달한다.</p>
</li>
<li><pre><code class="javascript">const person = &#123;&#125;;

// 데이터 프로퍼티 정의
Object.defineProperty(person, &#39;firstName&#39;, &#123;
  value: &#39;Youngseo&#39;,
  writable: true,
  enumerable: true,
  configurable:true
&#125;);

Object.defineProperty(person, &#39;lastName&#39;,&#123;
  value:&#39;Im&#39;
&#125;);

let descriptor = Object.getOwnPropertyDescriptor(person, &#39;firstName&#39;);
console.log(&#39;firstName&#39;, descriptor);
// firstName &#123;value: &quot;Youngseo&quot;, writable: true, enumerable: true, configurable:true&#125;

// 디스크립터 객체의 프로퍼티를 누락시키면 undefined가 기본값이다.
descriptor = Object.getOwnPropertyDescriptor(person, &#39;lastName&#39;);
console.log(&#39;lastName&#39;, descriptor);
//firstName &#123;value : &quot;Youngseo&quot;, writable: true, enumerable:true, configurable: true&#125;

// 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.
descriptor = Object.getOwnPropertyDescriptor(person, &#39;lastName&#39;);
console.log(&#39;lastName&#39;, descriptor);
// lastName &#123;value : &quot;Im&quot;, writable: false, enumerable:false, configurable: false&#125;

// [[Enumerable]]의 값이 false인 경우
// 해당 프로퍼티는 for..in 문이나 Object.keys 등으로 열거할 수 없다.
// lastName 프로퍼티는 [[Enumerable]]의 값이 false 이므로 열거되지 않는다.
console.log(Object.keys(person)); // [&quot;firsName&quot;]

// [[Writable]]의 값이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.
// lastName 프로퍼티는 [[Writable]]의 값이 false이므로 값을 변경할 수 없다.
// 이때 값을 변경하면 에러는 발생하지 않고 무시된다.
person.lastName = &#39;Kim&#39;;

// [[Configurable]]의 값이 false인 경우 해당 프로퍼티를 삭제할 수 없다.
// lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.
// 이때 프로퍼티를 삭제하면 에러는 발생하지 않고 무시된다.
delete person.lastName;

// [[Configurable]]의 값이 false인 경우 해당 프로퍼티를 재정의할 수 없다.
// Object.defineProperty(person, &#39;lastName&#39;, &#123; enumerable: true &#125;);
// Uncaught TypeError: Cannot redefine property: lastName

descriptor = Object.getOwnPropertyDescriptor(person, &#39;lastName&#39;);
console.log(&#39;lastName&#39;, descriptor);
// lastName &#123;value: &quot;Lee&quot;, writable: false, enumerable: false, configurable: false&#125;

// 접근자 프로퍼티 정의
Object.defineProperty(person, &#39;fullName&#39;, &#123;
  // getter 함수
  get() &#123;
    return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;
  &#125;,
  // setter 함수
  set(name) &#123;
    [this.firstName, this.lastName] = name.split(&#39; &#39;);
  &#125;,
  enumerable: true,
  configurable: true
&#125;);

descriptor = Object.getOwnPropertyDescriptor(person, &#39;fullName&#39;);
console.log(&#39;fullName&#39;, descriptor);
// fullName &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;

person.fullName = &#39;Heegun Lee&#39;;
console.log(person); // &#123;firstName: &quot;Heegun&quot;, lastName: &quot;Lee&quot;&#125;
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7. Object.defineProperty 메서드로 프로퍼티를 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있다. 프로퍼티 디스크립터 객체에서 생략된 어트리뷰트는 다음과 같이 기본값이 적용된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1. | 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략했을 때의 기본값 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | :---------------------------------- | :--------------------------- | :------------------- |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | value                               | [[Value]]                    | undefined            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | get                                 | [[Get]]                      | undefined            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | set                                 | [[Set]]                      | undefined            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | writable                            | [[Writable]]                 | false                |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | enumerable                          | [[Enumerable]]               | false                |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      | configurable                        | [[Configurable]]             | false                |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8. Object.defineProperty 메서드는 한번에 하나의 프로퍼티만 정의할 수 있고 Object.defineProperties 메서드를 사용하면 여러 개의 프로퍼티를 한 번에 정의 할 수 있다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9. &amp;lt;img width&amp;#x3D;&amp;quot;504&amp;quot; alt&amp;#x3D;&amp;quot;스크린샷 2020-09-21 오후 5 31 04&amp;quot; src&amp;#x3D;&amp;quot;https:&amp;#x2F;&amp;#x2F;user-images.githubusercontent.com&amp;#x2F;68043654&amp;#x2F;93746777-a714a800-fc30-11ea-8ef6-6de517db70a2.png&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 객체 변경 방지&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다 즉, 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티 값을 갱신할 수 있으며, Object.defineProperty 또는 Object.defineProperties 메서드를 사용하여 프로퍼티 어트리뷰트를 재정의 할 수도 있다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다 객체 변경 방지 메서드 들은 객체의 변경을 금지하는 강도가 다르다 .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. | 구분           | 메서드                   | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   | :------------- | :----------------------- | :-----------: | :-----------: | :--------------: | :--------------: | :------------------------: |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   | 객체 확장 금지 | Object.preventExtensions |       ✕       |       ○       |        ○         |        ○         |             ○              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   | 객체 밀봉      | Object.seal              |       ✕       |       ✕       |        ○         |        ○         |             ✕              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   | 객체 동결      | Object.freeze            |       ✕       |       ✕       |        ○         |        ✕         |             ✕              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 객체 확장 금지&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. Object.preventExtensions 메서드는 객체의 확장을 금지한다. 객체 확장 금지란 프로퍼티 추가 금지를 의미한다. **확장이 금지된 객체는 프로퍼티 추가가 금지된다.**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 프로퍼티는 프로퍼티 동적 추가와 Object.defineProperty 메서드로 추가할 수 있다. 이 두 가지 추가 방법이 모두 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 확장이 가능한 객체인지 여부는 Object.isExtensible 메서드로 확인할 수 있다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. &amp;#96;&amp;#96;&amp;#96;javascript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   const person &amp;#x3D; &amp;#123; name: &amp;#39;Lee&amp;#39; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; person 객체는 확장이 금지된 객체가 아니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isExtensible(person)); &amp;#x2F;&amp;#x2F; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; person 객체의 확장을 금지하여 프로퍼티 추가를 금지한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object.preventExtensions(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; person 객체는 확장이 금지된 객체다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isExtensible(person)); &amp;#x2F;&amp;#x2F; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 추가가 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   person.age &amp;#x3D; 20; &amp;#x2F;&amp;#x2F; 무시. strict mode에서는 에러&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;name: &amp;quot;Lee&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 추가는 금지되지만 삭제는 가능하다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   delete person.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 정의에 의한 프로퍼티 추가도 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object.defineProperty(person, &amp;#39;age&amp;#39;, &amp;#123; value: 20 &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; TypeError: Cannot define property age, object is not extensible&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
</li>
</ol>
<h3 id="객체-밀봉"><a href="#객체-밀봉" class="headerlink" title="객체 밀봉"></a>객체 밀봉</h3><ol>
<li><p>Object.seal 메서드는 객체를 밀봉한다 객체 밀봉이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다.</p>
</li>
<li><p><strong>밀봉된 객체는 읽기와 쓰기만 가능하다.</strong></p>
</li>
<li><p>밀봉된 객체의 여부는 Object.isSealed 메서드로 확인 할 수 있다.</p>
</li>
<li><pre><code class="javascript">const person = &#123; name: &#39;Lee&#39; &#125;;

// person 객체는 밀봉(seal)된 객체가 아니다.
console.log(Object.isSealed(person)); // false

// person 객체를 밀봉(seal)하여 프로퍼티 추가, 삭제, 재정의를 금지한다.
Object.seal(person);

// person 객체는 밀봉(seal)된 객체다.
console.log(Object.isSealed(person)); // true

// 밀봉(seal)된 객체는 configurable이 false다.
console.log(Object.getOwnPropertyDescriptors(person));
/*
&#123;
  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: false&#125;,
&#125;
*/

// 프로퍼티 추가가 금지된다.
person.age = 20; // 무시. strict mode에서는 에러
console.log(person); // &#123;name: &quot;Lee&quot;&#125;

// 프로퍼티 삭제가 금지된다.
delete person.name; // 무시. strict mode에서는 에러
console.log(person); // &#123;name: &quot;Lee&quot;&#125;

// 프로퍼티 값 갱신은 가능하다.
person.name = &#39;Kim&#39;;
console.log(person); // &#123;name: &quot;Kim&quot;&#125;

// 프로퍼티 어트리뷰트 재정의가 금지된다.
Object.defineProperty(person, &#39;name&#39;, &#123; configurable: true &#125;);
// TypeError: Cannot redefine property: name
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 객체 동결&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. Object.freeze 메서드는 객체를 동결한다. 객체 동결이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. **동결된 객체는 읽기만 가능하다.**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 동결된 객체의 여부는 Object.isFrozen 메서드로 확인 할 수 있다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. &amp;#96;&amp;#96;&amp;#96;javascript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   const person &amp;#x3D; &amp;#123; name: &amp;#39;Lee&amp;#39; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; person 객체는 동결(freeze)된 객체가 아니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isFrozen(person)); &amp;#x2F;&amp;#x2F; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; person 객체를 동결(freeze)하여 프로퍼티 추가, 삭제, 재정의, 쓰기를 금지한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object.freeze(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; person 객체는 동결(freeze)된 객체다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isFrozen(person)); &amp;#x2F;&amp;#x2F; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 동결(freeze)된 객체는 writable과 configurable이 false다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.getOwnPropertyDescriptors(person));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     name: &amp;#123;value: &amp;quot;Lee&amp;quot;, writable: false, enumerable: true, configurable: false&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 추가가 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   person.age &amp;#x3D; 20; &amp;#x2F;&amp;#x2F; 무시. strict mode에서는 에러&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;name: &amp;quot;Lee&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 삭제가 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   delete person.name; &amp;#x2F;&amp;#x2F; 무시. strict mode에서는 에러&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;name: &amp;quot;Lee&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 값 갱신이 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   person.name &amp;#x3D; &amp;#39;Kim&amp;#39;; &amp;#x2F;&amp;#x2F; 무시. strict mode에서는 에러&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;name: &amp;quot;Lee&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 프로퍼티 어트리뷰트 재정의가 금지된다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object.defineProperty(person, &amp;#39;name&amp;#39;, &amp;#123; configurable: true &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; TypeError: Cannot redefine property: name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;


</code></pre>
</li>
</ol>
<h3 id="불변-객체"><a href="#불변-객체" class="headerlink" title="불변 객체"></a>불변 객체</h3><ol>
<li><p>지금까지 살펴본 변경 방지 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못한다. 따라서 Object.freeze 메서드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.</p>
</li>
<li><pre><code class="javascript">const person = &#123;
  name: &#39;Lee&#39;,
  address: &#123; city: &#39;Seoul&#39; &#125;
&#125;;

// 얕은 객체 동결
Object.freeze(person);

// 직속 프로퍼티만 동결한다.
console.log(Object.isFrozen(person)); // true
// 중첩 객체까지 동결하지 못한다.
console.log(Object.isFrozen(person.address)); // false

person.address.city = &#39;Busan&#39;;
console.log(person); // &#123;name: &quot;Lee&quot;, address: &#123;city: &quot;Busan&quot;&#125;&#125;
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. &amp;#96;&amp;#96;&amp;#96;javascript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   const person &amp;#x3D; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     name: &amp;#39;Lee&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     address: &amp;#123; city: &amp;#39;Seoul&amp;#39; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 얕은 객체 동결&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object.freeze(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 직속 프로퍼티만 동결한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isFrozen(person)); &amp;#x2F;&amp;#x2F; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 중첩 객체까지 동결하지 못한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isFrozen(person.address)); &amp;#x2F;&amp;#x2F; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   person.address.city &amp;#x3D; &amp;#39;Busan&amp;#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;name: &amp;quot;Lee&amp;quot;, address: &amp;#123;city: &amp;quot;Busan&amp;quot;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체(immutable object, “12.6. 참조에 의한 전달과 외부 상태의 변경” 참고)를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   function deepFreeze(target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#x2F;&amp;#x2F; 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     if (target &amp;amp;&amp;amp; typeof target &amp;#x3D;&amp;#x3D;&amp;#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; !Object.isFrozen(target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Object.freeze(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#x2F;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         모든 프로퍼티를 순회하며 재귀적으로 동결한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         (&amp;quot;19.15.2. Object.keys&amp;#x2F;values&amp;#x2F;entries 메서드&amp;quot; 참고)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         (&amp;quot;27.9.2. Array.prototype.forEach&amp;quot; 참고)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Object.keys(target).forEach(key &amp;#x3D;&amp;gt; deepFreeze(target[key]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     return target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   const person &amp;#x3D; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     name: &amp;#39;Lee&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     address: &amp;#123; city: &amp;#39;Seoul&amp;#39; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 깊은 객체 동결&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   deepFreeze(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isFrozen(person)); &amp;#x2F;&amp;#x2F; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;&amp;#x2F; 중첩 객체까지 동결한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(Object.isFrozen(person.address)); &amp;#x2F;&amp;#x2F; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   person.address.city &amp;#x3D; &amp;#39;Busan&amp;#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(person); &amp;#x2F;&amp;#x2F; &amp;#123;name: &amp;quot;Lee&amp;quot;, address: &amp;#123;city: &amp;quot;Seoul&amp;quot;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/14/%20javascript%20TIL%20200914%20(Function%20review)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/%20javascript%20TIL%20200914%20(Function%20review)/" class="post-title-link" itemprop="url">Javascript TIL (Function Review)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-09-14 22:30:59" itemprop="dateCreated datePublished" datetime="2020-09-14T22:30:59+09:00">2020-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-09-17 19:11:43" itemprop="dateModified" datetime="2020-09-17T19:11:43+09:00">2020-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="유사배열이란"><a href="#유사배열이란" class="headerlink" title="유사배열이란?"></a>유사배열이란?</h3><ol>
<li>유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수도 있다.</li>
</ol>
<h3 id="변수-선언과-함수-정의"><a href="#변수-선언과-함수-정의" class="headerlink" title="변수 선언과 함수 정의"></a>변수 선언과 함수 정의</h3><ol>
<li>변수는 ‘선언(declaration)’ , 함수는 ‘’정의(definition)’</li>
<li>함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다 .</li>
<li>변수 선언문이 평가되면 초기화가 진행되면서 undefined가 할당된다(let,const는 제외)</li>
</ol>
<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><ol>
<li>기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석되고, 함수 선언문은 함수 이름을 생략할 수 없다 그러므로 둘은 같은 형태를 가지게 된다</li>
<li>하지만 그룹 연산자 내의 함수 리터럴은 단독으로 사용되어도 함수 선언문으로 해석되지 않고 함수 리터럴로 해석된다 </li>
<li>함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성 한다는 점에서 동일하지만 호출에 차이가 있다.</li>
<li><strong>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자</strong>라고 했다 이는 함수 <strong>몸체 외부에서는 함수 이름으로 함수를 참조할 수 없다</strong>는 뜻이다 즉, <strong>함수를 가리키는 식별자가 없다</strong>는 것과 마찬가지다.</li>
<li>하지만 함수 선언문으로 정의된 함수를 <strong>함수 이름으로 호출을 할 경우에 호출되는 현상이 발생</strong>하는데 이는 <strong>자바스크립트 엔진이 암묵적으로 생성한 식별자</strong>다 이때 함수 이름과 동일한 이름으로 식별자를 생성해 내는데 이는 <strong>함수 이름이 아닌 함수의 객체를 가리키는 식별자</strong> 이다 .</li>
<li>이로 인해 함수 선언문이 함수 표현식으로 변환해 객체를 생성한다고 생각할 수 있다 단, 정확하게 동일하게 동작하는 것은 아니다.</li>
</ol>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><ol>
<li>자바스크립트의 함수 = 일급 객체 = 값으로 사용가능</li>
<li>함수는 일급 객체 이므로 함수 객체를 변수에 할당할 수 있다.</li>
<li>함수 리터럴 함수는 이름을 생략할 수 있고(익명 함수, 기명함수), 익명함수가 일반적이다 .</li>
</ol>
<h3 id="함수-선언문-함수-표현식으로-정의한-함수의-생성-시점과-호이스팅"><a href="#함수-선언문-함수-표현식으로-정의한-함수의-생성-시점과-호이스팅" class="headerlink" title="함수 선언문, 함수 표현식으로 정의한 함수의 생성 시점과 호이스팅"></a>함수 선언문, 함수 표현식으로 정의한 함수의 생성 시점과 호이스팅</h3><ol>
<li>모든 선언문은 runtime 이전에 생성되어 실행된다.</li>
<li><strong>함수 선언문</strong>으로 함수를 정의하면 <strong>runtime 이전에 함수 객체가 먼저 생성된다, 이후에 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당</strong>한다. <ol>
<li>즉, runtime 시점에서는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다.</li>
<li>따라서 함수 선언문 이전에 함수를 참조하고 호출할 수 있다.</li>
<li><strong>이러한 현상을 함수 호이스팅이라고 한다.</strong></li>
</ol>
</li>
<li><strong>함수 표현식</strong>은 변수에 할당되는 값이 함수 리터럴인 문이다, 따라서 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작한다.<ol>
<li>변수 선언은 runtime 이전에 실행되어 undefined로 초기화되지만 <strong>변수 할당문의 값은 runtime 시점에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</strong></li>
<li>따라서 <strong>함수 표현식으로 함수를 정의하면 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.</strong></li>
</ol>
</li>
</ol>
<h3 id="매개-변수-parameter-와-인수-argument"><a href="#매개-변수-parameter-와-인수-argument" class="headerlink" title="매개 변수(parameter)와 인수(argument)"></a>매개 변수(parameter)와 인수(argument)</h3><ol>
<li>인수는 값으로 평가될 수 있는 표현식 이어야 하고 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.</li>
<li>매개 변수의 스코프는 함수 내부이다.</li>
<li>매개 변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.<ol>
<li>그냥 버려지는 것은 아니고 모든 인수는 암묵적으로 arguments 객체의 propery로 보관된다.</li>
</ol>
</li>
</ol>
<h3 id="즉시-실행-함수"><a href="#즉시-실행-함수" class="headerlink" title="즉시 실행 함수"></a>즉시 실행 함수</h3><ol>
<li>익명,기명 즉시 실행 함수가 있고  익명 함수를 사용하는 것이 일반적이다.</li>
<li>그룹 연산자(…)내의 기명 즉시 실행 함수는 함수 선언문이 아닌 리터럴로 평가되며, 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수 없다.</li>
<li>그룹 연산자로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.</li>
</ol>
<h2 id="재귀-함수"><a href="#재귀-함수" class="headerlink" title="재귀 함수"></a>재귀 함수</h2><h3 id="재귀의-3가지-중요한-특성"><a href="#재귀의-3가지-중요한-특성" class="headerlink" title="재귀의 3가지 중요한 특성"></a>재귀의 3가지 중요한 특성</h3><h4 id="종료-조건"><a href="#종료-조건" class="headerlink" title="종료 조건"></a>종료 조건</h4><ol>
<li>if문을 이용한 재귀의 무한루프 방지 if(조건이 어긋나면) {정지};</li>
<li>음수의 팩토리얼을 구하는 것은 불가능하다 때문에 음수 입력 값이 들어왔을 때 팩토리얼 함수가 작동하지 않도록 해야한다 .</li>
</ol>
<h4 id="기반-조건-Base-case-기저-상태"><a href="#기반-조건-Base-case-기저-상태" class="headerlink" title="기반 조건(Base case, 기저 상태)"></a>기반 조건(Base case, 기저 상태)</h4><ol>
<li>if(이런 일이 일어난다면) {성공}; 과 같이 이해하면 편하다.</li>
<li>종료 조건이 멈춰야 하는 안좋은 데이터를 고르는 것이라면 기반 조건은 재귀 함수의 목적이다.</li>
</ol>
<h3 id="재귀"><a href="#재귀" class="headerlink" title="재귀"></a>재귀</h3><ol>
<li>재귀란 함수가 자기 자신을 호출하는 것이다.</li>
</ol>
<h3 id="팩토리얼-함수-흐름"><a href="#팩토리얼-함수-흐름" class="headerlink" title="팩토리얼 함수 흐름"></a>팩토리얼 함수 흐름</h3><ol>
<li><img width="283" alt="스크린샷 2020-09-14 오후 10 09 46" src="https://user-images.githubusercontent.com/68043654/93090211-66200f00-f6d7-11ea-95fd-2d7cec2a69fb.png"></li>
<li>factorial(3); &gt;&gt;&gt; 숫자 3을 넘겨서 함수를 호출한다.</li>
<li>함수가 동작하고 if 문을 넘어가서 재귀 부분을 실행한다, 정수 3과 factorial(3-1)이 곱해진 결과를 반환한다.<ol>
<li>return 3 * factorial (2) ; </li>
</ol>
</li>
<li>Factorial (2) 가 동작할 때, if를 다시 넘어가고 재귀가 일어난다, 정수 2와 factorial(2-1)이 곱해진 결과를 반환한다.<ol>
<li>return 2 * factorial(1);</li>
</ol>
</li>
<li>factorial(1)이 동작할 때, if문이 또 한번 넘어가게 되고 재귀가 일어난다, 정수 1과 factorial(1-1)이 곱해진 결과를 반환한다.<ol>
<li>return 1 * factorial (0); </li>
</ol>
</li>
<li>factorial (0)은 기반 조건이기 때문에 1을 반환한다.<ol>
<li>if(x===0) return 1;</li>
</ol>
</li>
<li><strong>재귀는 단순히 중첩된 함수 호출이기 때문에 모든 중첩된 함수에서 가장 내부에 중첩된 함수가 가장 먼저 반환된다.</strong><ol>
<li>factorial(0) 은 1</li>
<li>factorial(1) 은 1 * factorial(0) 또는 1 * 1</li>
<li>factorial(2) 은 2 * factorial(1) 또는 2 * 1 * 1</li>
<li>factorial(3) 은 factorial(2) 또는 3 * 2 * 1 * 1</li>
<li>return 1 * 1 * 2 * 3 // 6</li>
</ol>
</li>
<li>재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 루프에 빠질 위험이 있다</li>
<li>따라서 재귀 함수를 사용하는 것이 더 직관적인 경우에만 사용한다 .</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/08/Javascript%20Practice%2020200908/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/Javascript%20Practice%2020200908/" class="post-title-link" itemprop="url">Javascript Practice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-09-08 20:50:59" itemprop="dateCreated datePublished" datetime="2020-09-08T20:50:59+09:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-09-12 08:23:22" itemprop="dateModified" datetime="2020-09-12T08:23:22+09:00">2020-09-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1번-과제"><a href="#1번-과제" class="headerlink" title="1번 과제"></a>1번 과제</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> res;</span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</span><br><span class="line">  res = <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  res = <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  res = <span class="string">&#x27;홀수&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위의 코드를 삼항 연산자로 바꾸시오.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> res = x === <span class="number">0</span> ? <span class="string">&#x27;영&#x27;</span> : (x % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">&#x27;짝수&#x27;</span> : <span class="string">&#x27;홀수&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2번-과제"><a href="#2번-과제" class="headerlink" title="2번 과제"></a>2번 과제</h1><h2 id="1-변수-x가-10보다-크고-20보다-작을-때-변수-x를-출력하는-조건식을-완성하라"><a href="#1-변수-x가-10보다-크고-20보다-작을-때-변수-x를-출력하는-조건식을-완성하라" class="headerlink" title="1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라"></a>1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"><span class="comment">// 변수 x 가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">10</span> &lt; x &amp;&amp; x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오"><a href="#3-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오" class="headerlink" title="3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오."></a>3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>)&#123; </span><br><span class="line">  str = str+i; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>



<h2 id="4-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#4-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i % <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-while문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#5-while문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="5. while문을 사용하여 0부터 10미만의 정수  중에서 짝수만을 작은 수부터 출력하시오."></a>5. while문을 사용하여 0부터 10미만의 정수  중에서 짝수만을 작은 수부터 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(count % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-while문을-사용하여-0-부터-10-미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#6-while문을-사용하여-0-부터-10-미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(count % <span class="number">2</span> === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오"><a href="#7-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오" class="headerlink" title="7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오."></a>7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  x = x + i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-1부터-20미만의-정수-중에서-2또는-3의-배수가-아닌-수의-총합을-구하시오"><a href="#8-1부터-20미만의-정수-중에서-2또는-3의-배수가-아닌-수의-총합을-구하시오" class="headerlink" title="8. 1부터 20미만의 정수 중에서 2또는 3의 배수가 아닌 수의 총합을 구하시오."></a>8. 1부터 20미만의 정수 중에서 2또는 3의 배수가 아닌 수의 총합을 구하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i % <span class="number">2</span> !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> !== <span class="number">0</span> )&#123;</span><br><span class="line">    x = x+i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>

<h2 id="9-1부터-20미만의-정수-중에서-2또는-3의-배수인-수의-총합을-구하시오"><a href="#9-1부터-20미만의-정수-중에서-2또는-3의-배수인-수의-총합을-구하시오" class="headerlink" title="9. 1부터 20미만의 정수 중에서 2또는 3의 배수인 수의 총합을 구하시오."></a>9. 1부터 20미만의 정수 중에서 2또는 3의 배수인 수의 총합을 구하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i % <span class="number">2</span> === <span class="number">0</span> || i % <span class="number">3</span> === <span class="number">0</span> )&#123;</span><br><span class="line">    x = x+i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="10-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오"><a href="#10-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오" class="headerlink" title="10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오."></a>10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">1</span>; x &lt;= <span class="number">6</span>; x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x + i === <span class="number">6</span>) <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;i&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-삼각형-출력하기-pattern-1"><a href="#11-삼각형-출력하기-pattern-1" class="headerlink" title="11. 삼각형 출력하기 - pattern 1"></a>11. 삼각형 출력하기 - pattern 1</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line= <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">var</span> star = <span class="number">0</span>; star &lt;= i; star++)&#123;</span><br><span class="line">   line += <span class="string">&quot;*&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> line += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(line);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-삼각형-출력하기-pattern-2"><a href="#12-삼각형-출력하기-pattern-2" class="headerlink" title="12. 삼각형 출력하기 - pattern 2"></a>12. 삼각형 출력하기 - pattern 2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> star = <span class="number">5</span>; star &gt; i ; star--)&#123;</span><br><span class="line"></span><br><span class="line">    line += <span class="string">&quot;*&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  line += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(i === <span class="number">0</span>)&#123;</span><br><span class="line">    line += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i === <span class="number">1</span>)&#123;</span><br><span class="line">      line += <span class="string">&#x27;  &#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i === <span class="number">2</span>)&#123;</span><br><span class="line">      line += <span class="string">&#x27;   &#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i === <span class="number">3</span>)&#123;</span><br><span class="line">      line += <span class="string">&#x27;    &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(line);</span><br></pre></td></tr></table></figure>

<h2 id="13-삼각형-출력하기-pattern-3"><a href="#13-삼각형-출력하기-pattern-3" class="headerlink" title="13. 삼각형 출력하기 - pattern 3"></a>13. 삼각형 출력하기 - pattern 3</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> star = <span class="number">5</span>; star &gt; i ; star--)&#123;</span><br><span class="line">    line += <span class="string">&quot;*&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  line += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(line);</span><br></pre></td></tr></table></figure>

<h2 id="14-삼각형-출력하기-pattern-4"><a href="#14-삼각형-출력하기-pattern-4" class="headerlink" title="14. 삼각형 출력하기 - pattern 4"></a>14. 삼각형 출력하기 - pattern 4</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> space = <span class="number">0</span>; space &lt;= max; space++)&#123;</span><br><span class="line">    star += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">      star += <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  star += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  max--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(star);</span><br></pre></td></tr></table></figure>

<h2 id="15-삼각형-출력하기-pattern-5"><a href="#15-삼각형-출력하기-pattern-5" class="headerlink" title="15. 삼각형 출력하기 - pattern 5"></a>15. 삼각형 출력하기 - pattern 5</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> spaceMax = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> starMax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;=<span class="number">4</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> space = <span class="number">0</span>; space &lt;= spaceMax; space++)&#123;</span><br><span class="line">    star += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= starMax; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= <span class="number">9</span> &amp;&amp; starMax &lt;=<span class="number">9</span>)&#123;</span><br><span class="line">    star += <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> space2 = <span class="number">0</span>; space2 &lt;= spaceMax; space2++ )&#123;</span><br><span class="line">    star += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  star += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  spaceMax--;</span><br><span class="line">  starMax += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(star);</span><br></pre></td></tr></table></figure>

<h2 id="16-삼각형-출력하기-pattern-6"><a href="#16-삼각형-출력하기-pattern-6" class="headerlink" title="16.삼각형 출력하기 - pattern 6"></a>16.삼각형 출력하기 - pattern 6</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> spaceMax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> starMax = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;=<span class="number">4</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> space = <span class="number">0</span>; space &lt; spaceMax; space++)&#123;</span><br><span class="line">    star += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; starMax; j++)&#123;</span><br><span class="line">    <span class="comment">// if(j &lt;= 9 &amp;&amp; starMax &lt;=9)&#123;</span></span><br><span class="line">    star += <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> space2 = <span class="number">0</span>; space2 &lt; spaceMax; space2++ )&#123;</span><br><span class="line">    star += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  star += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  spaceMax++;</span><br><span class="line">  starMax -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(star);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/02/Javascript%20TIL%2020200902%20(let,%20const%20and%20Block%20level%20scope)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/Javascript%20TIL%2020200902%20(let,%20const%20and%20Block%20level%20scope)/" class="post-title-link" itemprop="url">Javascript TIL (let, const and Block level scope)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-09-02 20:04:59 / Updated at: 20:05:17" itemprop="dateCreated datePublished" datetime="2020-09-02T20:04:59+09:00">2020-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="var-키워드로-선언한-변수의-문제점"><a href="#var-키워드로-선언한-변수의-문제점" class="headerlink" title="var 키워드로 선언한 변수의 문제점"></a>var 키워드로 선언한 변수의 문제점</h2><ol>
<li>ES5 까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. Var 키워드로 선언된 변수는 다음과 같은 특징이 있다, 이는 다른 언어와는 구별되는 독특한 특징으로 주의를 기울이지 않으면 심각한 문제를 발생시킬 수 있다</li>
</ol>
<h3 id="변수-중복-선언-허용"><a href="#변수-중복-선언-허용" class="headerlink" title="변수 중복 선언 허용"></a>변수 중복 선언 허용</h3><ol>
<li>var 키워드로 선언한 변수는 중복 선언이 가능하다 다음 예제를 살펴보자.</li>
<li><img width="571" alt="스크린샷 2020-09-02 오후 6 39 32" src="https://user-images.githubusercontent.com/68043654/91965820-ff503c80-ed4b-11ea-8481-c9f00b99dcdf.png"></li>
<li>위 예제의 var 키워드로 선언한 x변수와 y변수는 중복 선언되었다 이처럼 var 키워드로 선언한 변수를 중복 선언하면 초기화문(변수 선언과 동시에 초기값을 할당하는 문) 유무에 따라 다르게 동작한다 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시된다 이때 에러는 발생하지 않는다</li>
<li>위 예제와 같이 만약 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생한다.</li>
</ol>
<h3 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h3><ol>
<li>var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.</li>
<li><img width="515" alt="스크린샷 2020-09-02 오후 6 44 44" src="https://user-images.githubusercontent.com/68043654/91966383-b947a880-ed4c-11ea-9d63-8d7cbc59c3f1.png"></li>
<li>for 문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다.</li>
<li><img width="546" alt="스크린샷 2020-09-02 오후 6 55 14" src="https://user-images.githubusercontent.com/68043654/91967427-30317100-ed4e-11ea-996c-ef1c12c2386b.png"></li>
<li>함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.</li>
</ol>
<h3 id="변수-호이스팅"><a href="#변수-호이스팅" class="headerlink" title="변수 호이스팅"></a>변수 호이스팅</h3><ol>
<li>앞에서 여러번 말했듯이 var 키워드로 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어올려진 것처럼 동장한다.</li>
<li>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.</li>
</ol>
<h2 id="let-키워드"><a href="#let-키워드" class="headerlink" title="let 키워드"></a>let 키워드</h2><ol>
<li>앞에서 살펴본 var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 let과 const를 도입했다 var 키워드와의 차이점을 중심으로 let 키워드를 살펴보자.</li>
</ol>
<h3 id="변수-중복-선언-금지"><a href="#변수-중복-선언-금지" class="headerlink" title="변수 중복 선언 금지"></a>변수 중복 선언 금지</h3><ol>
<li>var 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러가 발생하지 않는다 이때 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 재할당되어 변경되는 부작용이 발생한다.</li>
<li>하지만 let 키워드로 이름이 같은 변수를 중복 선언하면 문법에러가 발생한다.</li>
<li><img width="585" alt="스크린샷 2020-09-02 오후 7 03 35" src="https://user-images.githubusercontent.com/68043654/91968264-5a376300-ed4f-11ea-8692-b8998ae3f08a.png">

</li>
</ol>
<h3 id="블록-레벨-스코프"><a href="#블록-레벨-스코프" class="headerlink" title="블록 레벨 스코프"></a>블록 레벨 스코프</h3><ol>
<li>var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다 </li>
<li>하지만 let 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, for 문, while 문, tty/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다 .</li>
<li><img width="455" alt="스크린샷 2020-09-02 오후 7 19 56" src="https://user-images.githubusercontent.com/68043654/91969792-a388b200-ed51-11ea-8d9f-b0f9bec6c178.png"></li>
<li>Let 키워드로 선언된 변수는 블록 레벨 스코프를 따른다 따라서 위 예제의 코드 블록 내에서 선언된 foo 변수와 bar 변수는 지역 변수다 전역에서 선언된 foo 변수와 코드 블록 내에서 선언된 foo 변수는 다른 별개의 변수다 또한 bar 변수도 블록 레벨 스코프를 갖는 지역 변수다 따라서 전역에서는 bar 변수를 참조할 수 없다.</li>
<li>함수도 코드 블록이므로 스코프를 만든다 이때 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다.</li>
<li><img width="490" alt="스크린샷 2020-09-02 오후 7 22 57" src="https://user-images.githubusercontent.com/68043654/91970060-0f6b1a80-ed52-11ea-9095-1e8885596954.png">

</li>
</ol>
<h3 id="변수-호이스팅-1"><a href="#변수-호이스팅-1" class="headerlink" title="변수 호이스팅"></a>변수 호이스팅</h3><ol>
<li>var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다 .</li>
<li><img width="490" alt="스크린샷 2020-09-02 오후 7 26 29" src="https://user-images.githubusercontent.com/68043654/91970393-8dc7bc80-ed52-11ea-9649-e7b9d5be567c.png"></li>
<li>이처럼 let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러가 발생한다.</li>
<li>앞에 변수 선언에서 살펴본 바와 같이 var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언 단계”와 “초기화 단계”가 한번에 진행된다.</li>
<li>하지만 <strong>let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다.</strong></li>
<li>즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.</li>
<li>만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(Temporal Dead Zone; TDZ)**라고 부른다.</li>
<li><img width="428" alt="스크린샷 2020-09-02 오후 7 32 51" src="https://user-images.githubusercontent.com/68043654/91970972-71784f80-ed53-11ea-8941-28aff2369f51.png"></li>
<li><img width="477" alt="스크린샷 2020-09-02 오후 7 33 15" src="https://user-images.githubusercontent.com/68043654/91971013-7fc66b80-ed53-11ea-8c70-cde440e3414b.png"></li>
<li>결국 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 그렇지 않다.</li>
<li><img width="640" alt="스크린샷 2020-09-02 오후 7 35 19" src="https://user-images.githubusercontent.com/68043654/91971208-c9af5180-ed53-11ea-916f-9cbea01f7bf8.png"></li>
<li>let 키워드로 선언한 변수의 경우, 변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 foo의 값을 출력해야 한다 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러가 발생한다.</li>
<li>자바스크립트는 ES6에서 도입된 let,const를 포함해서 모든 선언(var,let,const,fnction,function*,class 등) 을 호이스팅한다.</li>
<li>단, ES6에서 도입된 let,const,class 를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ol>
<h3 id="전역-객체와-let"><a href="#전역-객체와-let" class="headerlink" title="전역 객체와 let"></a>전역 객체와 let</h3><ol>
<li>Var 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 된다 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수있다.</li>
<li><img width="412" alt="스크린샷 2020-09-02 오후 7 45 51" src="https://user-images.githubusercontent.com/68043654/91972183-43940a80-ed55-11ea-9cbd-282d920b23ea.png"></li>
<li>브라우저 환경 에서 출력<img width="242" alt="스크린샷 2020-09-02 오후 7 42 48" src="https://user-images.githubusercontent.com/68043654/91971848-d4b6b180-ed54-11ea-83df-18e00a27ca97.png"></li>
<li>Let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다 즉, window.foo 와 같이 접근할 수 없다. let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드)내에 존재하게 된다.</li>
</ol>
<h2 id="const-키워드"><a href="#const-키워드" class="headerlink" title="const 키워드"></a>const 키워드</h2><ol>
<li>const 키워드는 상수(constant)를 선언하기 위해 사용한다 하지만 반드시 상수만을 위해 사용하지는 않는다 이에 대해서는 후반부에 설명한다. const 키워드의 특징은 let 키워드와 대부분 동일하므로 let 키워드와 다른점을 중심으로 살펴보자.</li>
</ol>
<h3 id="선언과-초기화"><a href="#선언과-초기화" class="headerlink" title="선언과 초기화"></a>선언과 초기화</h3><ol>
<li><strong>const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.</strong></li>
<li>선언만 하고 할당만 할 경우에는 문법 에러가 발생한다.</li>
<li>const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ol>
<h3 id="재할당-금지"><a href="#재할당-금지" class="headerlink" title="재할당 금지"></a>재할당 금지</h3><ol>
<li>var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 <strong>const 키워드로 선언한 변수는 재할당이 금지된다.</strong></li>
</ol>
<h3 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h3><ol>
<li>const 키워드로 선언한 변수에 원시값을 할당한 경우 변수 값을 변경할 수 없다. 원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 있는 방법이 없기 때문이다 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 한다.</li>
<li>변수의 상대 개념인 <strong>상수는 재할당이 금지된 변수를 말한다.</strong> 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다.</li>
<li>단, 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있지만 상수는 재할당이 금지된다.</li>
<li>상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.</li>
<li><img width="443" alt="스크린샷 2020-09-02 오후 7 55 10" src="https://user-images.githubusercontent.com/68043654/91973066-8f937f00-ed56-11ea-8ff6-b657de66d7a0.png"></li>
<li>코드 내에서 사용한 0.1은 어떤 의미로 사용했는지 명확히 알기 어렵기 때문에 가독성이 좋지 않다 또한 세율을 의미하는 0.1은 쉽게 바뀌지 않는 값이며, 프로그램 전체에서 고정된 값을 사용해야 한다. 이때 세율을 상수로 정의하면 값의 의미를 쉽게 파악할 수 있고 변경될 수 없는 고정값으로 사용할 수 있다.</li>
<li>const 키워드로 선언된 변수는 재할당이 급지된다. *<em>const 키워드로 선언된 변수에 원시값을 할당한 경우, 원시값은 변경할 수 없는값</em>(immutable value)이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.**</li>
<li>또한 상수는 프로그램 전체에서 공통적으로 사용하므로 나중에 세율이 변경되면 상수만을 변경하면 되기 때문에 유지보수성이 대폭 향상된다.</li>
<li>일반적으로 상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다 여러 단어로 이루어진 경우에는 언더스코어(_)로 구분해서 스네이크 케이스로 표현하는 것이 일반적이다.</li>
<li><img width="483" alt="스크린샷 2020-09-02 오후 7 59 12" src="https://user-images.githubusercontent.com/68043654/91973380-1f392d80-ed57-11ea-80df-c59a3868d877.png">

</li>
</ol>
<h3 id="const-키워드와-객체"><a href="#const-키워드와-객체" class="headerlink" title="const 키워드와 객체"></a>const 키워드와 객체</h3><ol>
<li>const  키워드로 선언된 변수에 원시값을 할당한 경우 값을 변경할 수 없다 하지만 <strong>const 키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할 수 있다.</strong></li>
<li>변경 불가능한 값인 원시값은 재할당없이 변경 할 수 있는 방법이 없지만 변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.</li>
<li><strong>const 키워드는 재할당을 금지할 뿐 “불변”을 의미하지는 않는다.</strong></li>
<li>다시 말해 새로운 값을 재할당 하는 것은 불가능하지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능하다 이때 객체가 변경되더라도 변수에 할당된 참조값은 변경되지 않는다.</li>
</ol>
<h2 id="var-vs-let-vs-const"><a href="#var-vs-let-vs-const" class="headerlink" title="var vs let vs const"></a>var vs let vs const</h2><ol>
<li>변수 선언에는 기본적으로 const를 사용하고</li>
<li>let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다.</li>
<li>const 키워드를 사용하면 의도치 않은 재할당을 방지하기 때문에 좀 더 안전하다.</li>
<li>var 와 let 그리고 const 키워드는 다음과 같이 사용하는 것을 권장한다.<ol>
<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var,let 키워드보다 안전하다.</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://github.com/youngseoim.github.io/2020/09/01/Javascript%20TIL%2020200901%20(Variable,%20Problems%20with%20Global%20Variables)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngseoim">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youngseo's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/Javascript%20TIL%2020200901%20(Variable,%20Problems%20with%20Global%20Variables)/" class="post-title-link" itemprop="url">Javascript TIL (Variable, Problems with Global Variables)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-09-01 23:54:59" itemprop="dateCreated datePublished" datetime="2020-09-01T23:54:59+09:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-09-14 22:45:58" itemprop="dateModified" datetime="2020-09-14T22:45:58+09:00">2020-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="변수란-무엇인가-왜-필요한가"><a href="#변수란-무엇인가-왜-필요한가" class="headerlink" title="변수란 무엇인가? 왜 필요한가?"></a>변수란 무엇인가? 왜 필요한가?</h2><ol>
<li>애플리케이션은 데이터를 다룬다,</li>
<li>아무리 복잡한 애플리케이션이라고 해도 데이터를 입력받아 처리하고 출력하는 것이 전부다.</li>
<li>데이터를 갈아끼우거나 가져다 쓰거나 등의 일을 할때 필요한 개념이 변수라는 개념이다.</li>
<li>10 + 20 의 예제를 사람이 계산하려면 10, 20 , +라는 기호의 의미를 알고 있어야하며 식의 의미도 해석할 수 있어야하고 그러기 위해선 10 과 20, + 기호 와 결과값 30을 두뇌에 기억한다</li>
<li>자바스크립트 엔진도 사람과 유사하게 계산(평가evaluation)하려면 먼저 10,20 이라는 리터럴(literal)과 +라는 연산자(operator)의 의미를 알고 있어야 하며, 10 + 20 이라는 표현식(expression)의 의미도 해석(파싱parsing)할 수 있어야 한다, 컴퓨터는 메모리에 기억하고 CPU로 연산한다.</li>
<li>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다, 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 셀의 크기 1바이트 단위로 데이터를 저장하거나 읽어들인다.</li>
<li>4GB의 메모리는 약 43억개의 메모리 셀이 있고 그 셀들은 각각 고유의 주소를 갖는다 </li>
<li>메모리 셀에 저장된 10 이라는 값과 20이라는 값을 CPU가 연산을해 나온 결과값 30이 또 다른 메모리 셀에 저장이 되었다, 하지만 결과값 30을 재사용할 수 없다는 문제가 있다.</li>
<li>연산 결과 30을 재사용하고 싶다면 연산 결과 30이 저장된 메모리 공간에 직접 접근하는것 외에는 방법이 없다, 하지만 자바스크립트 엔진은 메모리를 어디에 저장했는지 프로그래머가 알려주지 않는다.</li>
<li>또한 직접적으로 접근하는 방법이 있다고 해도 그 주소를 통해 직접 접근하는 것은 치명적인 오류를 발생시킬 가능성이 매우 높은 위험한 일이다.</li>
<li>그렇기 때문에 메모리 공간의 주소를 기억하고 있는 변수라는 이름을 통해서 메모리에 접근한다<ol>
<li>score라는 변수명에 메모리 주소인(메모리 주소를 안다는 가정하에) 0x0669F913을 기억시킨다, 이때 메모리 주소에 직접 접근하는게 아니고 score 라는 변수 명으로 접근한다.</li>
<li>만약 30이라는 값이 담긴 값에 변수명이 score라면 30과 score는 동치관계이고 score라는 변수명이 30을 가리키고 있기때문에 둘 다 변수이다,이때 score라는 변수 명은 0x0669F913라는 메모리 주소를 기억하고 있다는 얘기이다.</li>
</ol>
</li>
<li><strong>변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.</strong></li>
<li>간단히 말하자면 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, <strong>값의 위치를 가리키는 상직적인이름</strong>이다.</li>
<li>이때 변수명은 값이 의미를 알 수 있게끔 네이밍 해야한다.</li>
<li>변수 이름은 개발자가 안전하게 메모리 공간의 주소로 접근하기 위한 용도이다.</li>
<li>변수에 여러개의 값을 저장하는 방법<ol>
<li>변수는 하나의 값을 저장하기 위한 메커니즘이다 여러 개의 값을 저장하려면 여러 개의 변수를 사용해야 한다 단, 배열이나 객체 같은 자료구조를 사용하면 관련이 있는 여러 개의 값을 그룹화해서 하나의 값처럼 사용할 수 있다.</li>
</ol>
</li>
<li>앞서 살펴본 코드를 변수를 사용해 다시 작성한다면 다음과 같다<ol>
<li>Var result = 10 + 20;</li>
</ol>
</li>
</ol>
<h2 id="식별자-identifier"><a href="#식별자-identifier" class="headerlink" title="식별자(identifier)"></a>식별자(identifier)</h2><ol>
<li>변수 이름을 식별자 라고도 한다, <strong>식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.</strong></li>
<li>식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계</li>
<li><strong>식별자는 값이 아니라 메모리 주소를 기억하고 있다.</strong></li>
<li>식별자는 **선언(declaration)**에 의해 자바스크립트 엔진에 존재를 알린다</li>
</ol>
<h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2><ol>
<li><strong>변수를 사용하려면 반드시 선언이 필요하다 변수를 선언할 때는 var,let,const 키워드를 사용한다.</strong></li>
<li>var score; // 변수 선언문<ol>
<li>변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다,</li>
<li>메모리는 해제가 될 경우 값을 지우는게 아니라 쓰레기 값을 그대로 두고 해제된다.</li>
<li>값을 할당하지 않은 경우 엔진에 의해 쓰레기 값을 초기화하며 암묵적으로 undefined라는 값을 할당한다. </li>
</ol>
</li>
</ol>
<h3 id="변수-선언의-실행-시점과-변수-호이스팅"><a href="#변수-선언의-실행-시점과-변수-호이스팅" class="headerlink" title="변수 선언의 실행 시점과 변수 호이스팅"></a>변수 선언의 실행 시점과 변수 호이스팅</h3><ol>
<li>자바스크립트는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 변수 선언보다 호출이 먼저 일어날 경우 다른언어들은 에러가 일어나지만 자바스크립트는 에러가 발생하지 않는다.</li>
<li>개발자가 사용하지 않을꺼라는걸 고려해 변수 선언문을 최상단에서 먼저 실행해(호이스팅) 에러가나서 프로그램이 멈추지 않도록 의도해서 만들어 졌기 때문이다.<ol>
<li>let과 const는 초기화 단계에서 사각지대가 존재해 호이스팅이 발생하지 않는것 처럼 보인다</li>
</ol>
</li>
<li>그렇다는건 <strong>변수 선언이 소스 코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행된다는 이야기다</strong></li>
<li>자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다 </li>
<li>그리고 평가 과정이 끝나면 비로소 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.</li>
</ol>
<h3 id="값의-할당"><a href="#값의-할당" class="headerlink" title="값의 할당"></a>값의 할당</h3><ol>
<li>주의할 점은 변수 선언 값의 할당의 실행 시점이 다르다는것이다.</li>
<li><strong>변수 선언은 소스 코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.</strong></li>
<li>var score = 80; // 변수 선언과 값의 할당을 var score 라는 변수 선언문과, score = 80 이라는 값의 할당 두가지 문으로 구분을 하기 때문이다</li>
<li>값을 할당할때에는 처음에 선언하면서 초기화된 undefined가 있던 메모리 공간에 80이라는 값이 할당되는게 아니고 </li>
<li>undefined는 가비지 콜렉터에 의해서 해제되고 그 값은 그 자리에 남아있고 80이라는 값은 새로운 메모리 공간을 확보해서 할당된다 .</li>
<li>이때 변수는 undefined가 담겨있던 메모리 공간의 주소를 기억하다가 80이 할당되면서 80이라는 값이 담겨있는 메모리 공간의 주소를 기억한다 .</li>
</ol>
<h1 id="Javascript-TIL-전역-변수의-문제점"><a href="#Javascript-TIL-전역-변수의-문제점" class="headerlink" title="Javascript TIL (전역 변수의 문제점)"></a>Javascript TIL (전역 변수의 문제점)</h1><h2 id="지역-변수의-생명-주기"><a href="#지역-변수의-생명-주기" class="headerlink" title="지역 변수의 생명 주기"></a>지역 변수의 생명 주기</h2><ol>
<li>변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다 그리고 언젠간 소멸한다 , 변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.</li>
<li>변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다.</li>
<li>하지만 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다 .</li>
<li><img width="440" alt="스크린샷 2020-09-01 오후 7 48 15" src="https://user-images.githubusercontent.com/68043654/91840918-6dcdc580-ec8c-11ea-88ef-ea46d44e3dcd.png">
1. 지역 변수 x 는 foo 함수가 호출되기 이전까지는 생성되지 않는다. foo 함수를 호출하지 않으면 함수 내부의 변수 선언문이 실행되지 않기 때문인다.
2. 변수 선언의 실행 시점과 변수 호이스팅에서 살펴보았듯이 변수 선언은 선언문이 어디에 있든 상관없이 가장 먼저 실행된다.
3. 다시 말해, 변수 선언은 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임에 실행되는 것이 아니라 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행된다.
4. 그런데 엄밀히 말하자면 위 설명은 전역 변수에 한정된 것이다. 함수 내부에서 선언한 변수는 함수가 호출된 직후에 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
5. 위 예제의 foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 x 변수의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화된다. 그 후 , 함수 몸체를 구성하는 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 x 변수에 값이 할당된다. 그리고 함수가 종료하면 x 변수도 소멸되어 생명 주기가 종료된다. 따라서 함수 내부에서 선언된 지역 변수 x 는 foo 함수가 호출되어 실행되는 동안에만 유효하다
6. 즉, **지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.**
7. <img width="501" alt="스크린샷 2020-09-01 오후 7 59 38" src="https://user-images.githubusercontent.com/68043654/91841862-03b62000-ec8e-11ea-9acc-252620290a99.png">
8. 함수 몸체 내부에서 선언된 지역 변수의 생명 주기는  함수의 생명 주기와 대부분 일치하지만 지역 변수가 함수보다 오래 생존하는 경우도 있다.
9. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. 따라서
10. **변수의 생명 주기는 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리 풀(memory pool)에 반환되는 시점**까지다.
11. 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 함수가 생성한 스코프는 렉시컬 환경이라 부르는 물리적인 실체가 있다고 했다 따라서 변수는 자신이 등록된 스코프가 소멸(스코프가 메모리에서 해제)될 때까지 유효하다.
12. 할당된 메모리 공간은 더 이상 그 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다 즉, 누군가가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아 있게 된다. 이는 스코프도 마찬가지다 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.
13. 일반적으로 함수과 종료하면 함수가 생성한 스코프도 소멸한다 하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하게 된다 이에 대해서는 클로저에서 자세히 살펴보도록 하자.
14. <img width="428" alt="스크린샷 2020-09-01 오후 8 18 13" src="https://user-images.githubusercontent.com/68043654/91843347-9c4d9f80-ec90-11ea-8a1f-cd6a6bcc0ec4.png">
    1. foo 함수 내부에서 선언된 지역 변수 x 는 1번의 시점에 이미 선언되었고 undefined로 초기화되어 있다 따라서 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조해 값을 출력한다 즉, 지역 변수는 함수 전체에서 유효하다 단, 변수 할당문이 실행되기 이전까지는 undefined 값을 갖는다.
    2. 이처럼 **호이스팅은 스코프를 단위로 동작한다.** 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두로 끌어 올려진 것처럼 동작한다 따라서 전역 변수는 전역 전체에서 유효하다 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 지역 변수는 함수 전체에서 유효하다.
    3. 즉,**호이스팅은 변수 선언이 스코프의 선두로 끌어  올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.**



</li>
</ol>
<h2 id="전역-변수의-생명-주기"><a href="#전역-변수의-생명-주기" class="headerlink" title="전역 변수의 생명 주기"></a>전역 변수의 생명 주기</h2><ol>
<li>함수와 달리 전역 코드는 명시적인 호출 없이 실행된다. 다시 말해 전역코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점(entry point)이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.</li>
<li>함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료한다 하지만 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.</li>
<li>var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다.</li>
<li>전역 객체(global object)<ol>
<li>전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다.</li>
<li>전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window</li>
<li>서버사이드 환경(node.js)에서는 global 객체를 의미한다.</li>
<li>환경에 따라 다양한 식별자(window, self, this, frames , global)가 존재했으나 ES11에서 globalThis로 통일되었다.</li>
<li>전역 객체에는 표준 빌트인 객체(Object, String, Number, Function, Array)와 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.</li>
</ol>
</li>
<li>브라우저 환경에서 전역 객체는 window 이므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다. 전역 객체 window는 웹페이지를 종료하기 전까지 유효하다 따라서 브라우저 환경에서 var 키워드로 선언한 전역 변수는 웹 페이지를 종료할 때까지 유효하다</li>
<li>즉, <strong>var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.</strong></li>
<li><img width="603" alt="스크린샷 2020-09-01 오후 8 40 35" src="https://user-images.githubusercontent.com/68043654/91845218-bccb2900-ec93-11ea-9ed6-7dadb3d68eb7.png">



</li>
</ol>
<h2 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h2><ol>
<li>암묵적 결합<ol>
<li>전역 변수를 선언한 의도는 어디서는 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합(implicit coupling)**을 허용하는 것이다.</li>
<li>변수의 유효범위가 크면 클수록 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.</li>
</ol>
</li>
<li>긴 생명 주기<ol>
<li><strong>전역 변수는 생명 주기가 길다.</strong> 따라서 메모리 리소스도 오랜 기간 소비한다 또한 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많다.</li>
<li>더욱이 var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다. 변수 이름이 중복되면 의도치 않은 재할당이 이뤄진다.</li>
</ol>
</li>
<li>스코프 체인 상에서 종점에 존재<ol>
<li>전역 변수는 스코프 체인 상에서 종점에 존재한다 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 말한다.</li>
<li>즉, <strong>전역 변수가 검색 속도가 가장 느리다.</strong> 검색 속도의 차이는 그다지 크지 않지만 속도의 차이는 분명히 있다.</li>
</ol>
</li>
<li>네임스페이스 오염<ol>
<li>자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다 .따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</li>
</ol>
</li>
</ol>
<h2 id="전역-변수의-사용을-억제하는-방법"><a href="#전역-변수의-사용을-억제하는-방법" class="headerlink" title="전역 변수의 사용을 억제하는 방법"></a>전역 변수의 사용을 억제하는 방법</h2><ol>
<li><strong>전역 변수를 반드시 사용해야 할 이유를 찾지 못했다면 지역 변수를 사용해야 한다. 변수의 스코프는 좁을수록 좋다.</strong></li>
<li>즉시 실행 함수<ol>
<li>함수의 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출된다.<strong>모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.</strong> 이러한 특성을 이용해 전역 변수의 사용을 제한하는 방법이다.</li>
<li>이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.</li>
</ol>
</li>
<li>네임스페이스 객체<ol>
<li>전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.<ol>
<li><img width="418" alt="스크린샷 2020-09-02 오후 5 41 58" src="https://user-images.githubusercontent.com/68043654/91959724-f52a4000-ed43-11ea-9fdc-1388b0599a72.png"></li>
</ol>
</li>
<li>네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가해서 네임스페이스를 계층적으로 구성할 수도 있다<ol>
<li><img width="418" alt="스크린샷 2020-09-02 오후 5 58 33" src="https://user-images.githubusercontent.com/68043654/91961545-45a29d00-ed46-11ea-9454-001a81f56bac.png"></li>
</ol>
</li>
<li>네임스페이스를 분리해서 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용해 보이지는 않는다.</li>
</ol>
</li>
<li>모듈 패턴<ol>
<li>모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다, 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다 모듈 패턴의 특징은 전역 변수의 억제는 물론 갭슐화까지 구현할 수 있다는 것이다.</li>
<li>캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조정할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다 </li>
<li>캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라고 한다.</li>
<li>대부분의 객체지향 프로그래밍 언어는 클래스를 구성하는 멤버에 대해 public, private, protected 등의 접근 제한자(access modifier)를 사용해 공개 범위를 한정할 수 있다 public으로 선언된 데이터 또는 메서드는 외부에서 접근이 가능하지만 private로 선언된 경우는 외부에서 접근할 수 없고 내부에서만 사용된다 </li>
<li>이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근으로부터 내부를 보호하는 기능을 한다.</li>
<li>하지만 자바스크립트는 public, private,protected등의 접근 제한자를 제공하지 않는다 모듈 패턴은 전역 네임스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용한다.</li>
<li><img width="438" alt="스크린샷 2020-09-02 오후 6 08 44" src="https://user-images.githubusercontent.com/68043654/91962595-b1393a00-ed47-11ea-8202-912958c3899c.png">
1. 위 예제의 즉시 실행 함수는 객체를 반환한다 이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다
2. 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버이다 
3. 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버가 된다 .
4. 이에 관해서는 클로저에서 자세히 살펴보자</li>
</ol>
</li>
<li>ES6 모듈<ol>
<li>ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다 .</li>
<li><strong>ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공</strong>한다. 즉, 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.</li>
<li>모던 브라우저(Chrome 61, FF60, SF 10.1, Edge 16 이상)에서 사용할 수 있으며 script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다 . 모듈의 파일 확장자는 mjs를 권장한다. </li>
<li>ES6 모듈은 IE를 포함한 구형 브라우저에서는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">youngseoim</p>
  <div class="site-description" itemprop="description">All Dev stories found in here</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngseoim</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
